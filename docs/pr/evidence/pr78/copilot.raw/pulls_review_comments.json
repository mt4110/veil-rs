[{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644092","pull_request_review_id":3808873517,"id":2812644092,"node_id":"PRRC_kwDOQkbgjc6npYr8","diff_hunk":"@@ -0,0 +1,290 @@\n+package main\n+\n+import (\n+\t\"archive/tar\"\n+\t\"compress/gzip\"\n+\t\"crypto/sha256\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+func CreateBundleUI(mode, outDir string, stdout, stderr io.Writer) error {\n+\tepoch, err := ComputeEpochSec()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\theadSHA, err := getGitHeadSHA()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfmt.Fprintf(stdout, \"Creating bundle (mode=%s, epoch=%d, head=%s)\\n\", mode, epoch, headSHA[:12])\n+\n+\t// C4: Pre-checks\n+\tisDirty, err := isGitDirty()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif mode == ModeStrict {\n+\t\tif isDirty {\n+\t\t\treturn NewVError(E_CONTRACT, \"git\", \"repository is dirty (prohibited in strict mode)\")\n+\t\t}\n+\t\t// Evidence check will come in C5/C6\n+\t} else if mode == ModeWIP {\n+\t\tif isDirty {\n+\t\t\tfmt.Fprintln(stderr, \"WARN: repository is dirty\")\n+\t\t}\n+\t}\n+\n+\t// C4: contract.json generation\n+\tcontract := &Contract{\n+\t\tContractVersion: \"1.1\",\n+\t\tMode:            mode,\n+\t\tRepo:            \"veil-rs\", // Canonical\n+\t\tEpochSec:        epoch,\n+\t\tBaseRef:         \"main\", // Canonical entry\n+\t\tHeadSHA:         headSHA,\n+\t\tWarningsCount:   0,\n+\t\tEvidence: Evidence{\n+\t\t\tRequired:    mode == ModeStrict,\n+\t\t\tPresent:     false,\n+\t\t\tBoundToHead: false,\n+\t\t\tPathPrefix:  DirEvidence,\n+\t\t},\n+\t\tTool: Tool{\n+\t\t\tName:    \"reviewbundle\",\n+\t\t\tVersion: \"1.0.0\",\n+\t\t},\n+\t}\n+\n+\tif isDirty {\n+\t\tcontract.WarningsCount++\n+\t}\n+\n+\t// C5/C6: Actual bundle generation\n+\tpath, err := CreateBundle(contract, outDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfmt.Fprintf(stdout, \"Bundle created: %s\\n\", path)\n+\treturn nil\n+}\n+\n+func CreateBundle(c *Contract, outDir string) (string, error) {\n+\tif err := os.MkdirAll(outDir, 0755); err != nil {\n+\t\treturn \"\", WrapVError(E_PATH, outDir, err)\n+\t}\n+\n+\tts := time.Unix(c.EpochSec, 0).UTC().Format(\"20060102_150405\")\n+\tname := fmt.Sprintf(\"veil-rs_review_%s_%s_%s.tar.gz\", c.Mode, ts, c.HeadSHA[:12])\n+\toutPath := filepath.Join(outDir, name)\n+\n+\ttmpPath := outPath + \".tmp\"\n+\tf, err := os.Create(tmpPath)\n+\tif err != nil {\n+\t\treturn \"\", WrapVError(E_PATH, tmpPath, err)\n+\t}\n+\tdefer os.Remove(tmpPath)\n+\tdefer f.Close()\n+\n+\tgw := gzip.NewWriter(f)\n+\tgw.Header.ModTime = time.Unix(c.EpochSec, 0)\n+\tgw.Header.OS = 255\n+\tdefer gw.Close()\n+\n+\ttw := tar.NewWriter(gw)\n+\tdefer tw.Close()\n+\n+\t// 1. Gather files\n+\tfiles := make(map[string][]byte)\n+\n+\t// INDEX.md\n+\tfiles[PathIndex] = []byte(fmt.Sprintf(\"# Review Bundle\\n\\nMode: %s\\nEpoch: %d\\nHead: %s\\n\", c.Mode, c.EpochSec, c.HeadSHA))\n+\n+\t// patch/series.patch\n+\tpatch, err := getGitPatch(c.BaseRef, c.HeadSHA)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tfiles[PathSeriesPatch] = patch\n+\n+\t// Evidence (Phase 7.5/8/9)\n+\tbound, evFiles, err := collectEvidence(c.HeadSHA)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tif len(evFiles) > 0 {\n+\t\tc.Evidence.Present = true\n+\t\tc.Evidence.BoundToHead = bound\n+\t\tfor name, content := range evFiles {\n+\t\t\tfiles[name] = content\n+\t\t}\n+\t}\n+\n+\t// meta/contract.json (update with evidence findings)\n+\tcj, _ := json.MarshalIndent(c, \"\", \"  \")\n+\tfiles[PathContract] = cj\n+\n+\t// 2. Generate SHA256SUMS (C6)\n+\tvar manifestKeys []string\n+\tfor k := range files {\n+\t\tmanifestKeys = append(manifestKeys, k)\n+\t}\n+\tsort.Strings(manifestKeys)\n+\n+\tvar sumsBuilder strings.Builder\n+\tfor _, k := range manifestKeys {\n+\t\th := sha256.Sum256(files[k])\n+\t\tfmt.Fprintf(&sumsBuilder, \"%x  %s\\n\", h, k)\n+\t}\n+\tsums := []byte(sumsBuilder.String())\n+\tfiles[PathSHA256SUMS] = sums\n+\n+\t// seal\n+\tseal := sha256.Sum256(sums)\n+\tfiles[PathSHA256SUMSSeal] = []byte(fmt.Sprintf(\"%x  %s\\n\", seal, PathSHA256SUMS))\n+\n+\t// 3. Sort and write (C5)\n+\tvar keys []string\n+\tfor k := range files {\n+\t\tkeys = append(keys, k)\n+\t}\n+\tsort.Strings(keys)\n+\n+\tfor _, k := range keys {\n+\t\tcontent := files[k]\n+\t\thdr := &tar.Header{\n+\t\t\tName:     k,\n+\t\t\tSize:     int64(len(content)),\n+\t\t\tMode:     0644,\n+\t\t\tModTime:  time.Unix(c.EpochSec, 0),\n+\t\t\tTypeflag: tar.TypeReg,\n+\t\t\tUid:      0,\n+\t\t\tGid:      0,\n+\t\t\tUname:    \"\",\n+\t\t\tGname:    \"\",\n+\t\t\tFormat:   tar.FormatPAX,\n+\t\t\t// Phase 4.2/7.3: Explicitly zero extra times to avoid PAX mtime/atime/ctime\n+\t\t\tAccessTime: time.Time{},\n+\t\t\tChangeTime: time.Time{},\n+\t\t\tPAXRecords: nil,\n+\t\t}\n+\t\tif err := tw.WriteHeader(hdr); err != nil {\n+\t\t\treturn \"\", WrapVError(E_GZIP, k, err)\n+\t\t}\n+\t\tif _, err := tw.Write(content); err != nil {\n+\t\t\treturn \"\", WrapVError(E_GZIP, k, err)\n+\t\t}\n+\t}\n+\n+\ttw.Close()\n+\tgw.Close()\n+\tf.Close()\n+\n+\tif err := os.Rename(tmpPath, outPath); err != nil {\n+\t\treturn \"\", WrapVError(E_PATH, outPath, err)\n+\t}\n+\n+\t// 4. Self-Audit (C6)\n+\t_, err = VerifyBundlePath(outPath)\n+\tif err != nil {\n+\t\t// If verification fails, we keep the broken bundle for inspection but return error\n+\t\treturn outPath, fmt.Errorf(\"self-audit failed for %s: %w\", outPath, err)\n+\t}\n+\n+\treturn outPath, nil\n+}\n+\n+func getGitPatch(base, head string) ([]byte, error) {\n+\tout, err := exec.Command(\"git\", \"format-patch\", \"--stdout\", base+\"..\"+head).Output()","path":"cmd/reviewbundle/create.go","commit_id":"3be0b5303f4604246b14cad24fbd804770ba84a9","original_commit_id":"4039a3ec26070e218fdfb1f2a77ba461c47272ee","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The git command concatenates user-controlled input (base and head) directly into the command without validation. While git itself will reject malicious input, this could lead to command injection if base contains special characters. Consider validating that base and head match expected ref patterns (e.g., alphanumeric, /, -, _) before using them in command construction.","created_at":"2026-02-16T14:15:25Z","updated_at":"2026-02-16T14:15:32Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644092","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644092"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644092"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644092/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":210,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":210,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644121","pull_request_review_id":3808873517,"id":2812644121,"node_id":"PRRC_kwDOQkbgjc6npYsZ","diff_hunk":"@@ -0,0 +1,475 @@\n+package main\n+\n+import (\n+\t\"archive/tar\"\n+\t\"compress/gzip\"\n+\t\"crypto/sha256\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"path\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+type Contract struct {\n+\tContractVersion string   `json:\"contract_version\"`\n+\tMode            string   `json:\"mode\"`\n+\tRepo            string   `json:\"repo\"`\n+\tEpochSec        int64    `json:\"epoch_sec\"`\n+\tBaseRef         string   `json:\"base_ref\"`\n+\tHeadSHA         string   `json:\"head_sha\"`\n+\tWarningsCount   int      `json:\"warnings_count\"`\n+\tEvidence        Evidence `json:\"evidence\"`\n+\tTool            Tool     `json:\"tool\"`\n+}\n+\n+type Evidence struct {\n+\tRequired    bool   `json:\"required\"`\n+\tPresent     bool   `json:\"present\"`\n+\tBoundToHead bool   `json:\"bound_to_head\"`\n+\tPathPrefix  string `json:\"path_prefix\"`\n+}\n+\n+type Tool struct {\n+\tName    string `json:\"name\"`\n+\tVersion string `json:\"version\"`\n+\tBuild   string `json:\"build,omitempty\"`\n+}\n+\n+type VerifyReport struct {\n+\tContract *Contract\n+\n+\t// computed\n+\tComputedSHA256 map[string][32]byte\n+\n+\t// extracted raw files (needed for seal/checks)\n+\tSHA256SUMS     []byte\n+\tSHA256SUMSSeal []byte\n+\tWarningsTxt    []byte\n+\tEvidenceFiles  [][]byte\n+\n+\t// required layout presence\n+\tHasIndex          bool\n+\tHasContractJSON   bool\n+\tHasSHA256SUMS     bool\n+\tHasSHA256SUMSSeal bool\n+\tHasSeriesPatch    bool\n+\n+\t// evidence scan result\n+\tEvidencePresent     bool\n+\tEvidenceBoundToHead bool\n+\n+\t// captured gzip header (for post-check)\n+\tGzipModTime time.Time\n+\tGzipName    string\n+\tGzipComment string\n+\tGzipExtra   []byte\n+\tGzipOS      byte\n+}\n+\n+func VerifyBundlePath(path string) (*VerifyReport, error) {\n+\tf, err := os.Open(path)\n+\tif err != nil {\n+\t\treturn nil, WrapVError(E_PATH, path, err)\n+\t}\n+\tdefer f.Close()\n+\treturn VerifyBundle(f)\n+}\n+\n+func VerifyBundle(r io.Reader) (*VerifyReport, error) {\n+\trep, err := verifyReportFromStream(r)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif err := verifyPostConditions(rep); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn rep, nil\n+}\n+\n+func verifyReportFromStream(r io.Reader) (*VerifyReport, error) {\n+\trep := &VerifyReport{\n+\t\tComputedSHA256: make(map[string][32]byte),\n+\t}\n+\n+\tgz, err := gzip.NewReader(r)\n+\tif err != nil {\n+\t\treturn nil, WrapVError(E_GZIP, \"stream\", err)\n+\t}\n+\tdefer gz.Close()\n+\n+\t// Capture gzip header\n+\trep.GzipModTime = gz.Header.ModTime\n+\trep.GzipName = gz.Header.Name\n+\trep.GzipComment = gz.Header.Comment\n+\trep.GzipExtra = gz.Header.Extra\n+\trep.GzipOS = gz.Header.OS\n+\n+\ttr := tar.NewReader(gz)\n+\tvar prevNameCanon string\n+\tvar seenFirst bool\n+\tvar seenSec int64\n+\n+\tfor {\n+\t\thdr, err := tr.Next()\n+\t\tif err == io.EOF {\n+\t\t\tbreak\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn nil, WrapVError(E_GZIP, \"tar stream corrupted\", err)\n+\t\t}\n+\n+\t\tname := hdr.Name\n+\n+\t\tif err := validateTarOrder(name, prevNameCanon, seenFirst); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tprevNameCanon = name\n+\t\tseenFirst = true\n+\n+\t\tif err := validateTarPath(name, hdr.Typeflag); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarType(name, hdr.Typeflag); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarIdentity(name, hdr); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarTime(name, hdr, &seenSec); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarPAX(name, hdr); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\tupdateLayoutPresence(name, hdr, rep)\n+\n+\t\tif err := processEntryContent(tr, hdr, rep); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\treturn rep, nil\n+}\n+\n+func validateTarOrder(name, prev string, seenFirst bool) error {\n+\tif seenFirst && name < prev {\n+\t\treturn NewVError(E_ORDER, name, fmt.Sprintf(\"is not sorted (prev: %s)\", prev))\n+\t}\n+\treturn nil\n+}\n+\n+func validateTarPath(name string, typeFlag byte) error {\n+\tif strings.HasPrefix(name, \"/\") {\n+\t\treturn NewVError(E_PATH, name, \"absolute path forbidden\")\n+\t}\n+\tif strings.Contains(name, \"\\x00\") {\n+\t\treturn NewVError(E_PATH, name, \"contains NUL char\")\n+\t}\n+\tif strings.Contains(name, \"\\\\\") {\n+\t\treturn NewVError(E_PATH, name, \"contains backslash\")\n+\t}\n+\tclean := path.Clean(name)\n+\tif clean == \"..\" || strings.HasPrefix(clean, \"../\") {\n+\t\treturn NewVError(E_PATH, name, \"parent traversal prohibited\")\n+\t}\n+\n+\t// Normalize check\n+\tnormalized := clean\n+\tif typeFlag == tar.TypeDir && !strings.HasSuffix(normalized, \"/\") {\n+\t\tif name != clean && name != clean+\"/\" {\n+\t\t\treturn NewVError(E_PATH, name, \"path not normalized\")\n+\t\t}\n+\t} else {\n+\t\tif name != clean {\n+\t\t\treturn NewVError(E_PATH, name, \"path not normalized\")\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func validateTarType(name string, flag byte) error {\n+\tswitch flag {\n+\tcase tar.TypeDir, tar.TypeReg, tar.TypeSymlink:\n+\t\treturn nil\n+\tdefault:\n+\t\treturn NewVError(E_TYPE, name, fmt.Sprintf(\"forbidden type flag: %c\", flag))\n+\t}\n+}\n+\n+func validateTarIdentity(name string, hdr *tar.Header) error {\n+\tif hdr.Uid != 0 || hdr.Gid != 0 {\n+\t\treturn NewVError(E_IDENTITY, name, fmt.Sprintf(\"non-zero uid/gid: %d/%d\", hdr.Uid, hdr.Gid))\n+\t}\n+\tif hdr.Uname != \"\" || hdr.Gname != \"\" {\n+\t\treturn NewVError(E_IDENTITY, name, fmt.Sprintf(\"non-empty uname/gname: %q/%q\", hdr.Uname, hdr.Gname))\n+\t}\n+\n+\t// Phase 7.6: Mode Normalization\n+\tmode := hdr.Mode & 0777\n+\tswitch hdr.Typeflag {\n+\tcase tar.TypeDir:\n+\t\tif mode != 0755 {\n+\t\t\treturn NewVError(E_IDENTITY, name, fmt.Sprintf(\"dir mode must be 0755 (got %o)\", mode))\n+\t\t}\n+\tcase tar.TypeReg:\n+\t\t// Check for executable bit in git's bitmask sense\n+\t\t// If executable (0755) or regular (0644)\n+\t\tif mode != 0644 && mode != 0755 {\n+\t\t\treturn NewVError(E_IDENTITY, name, fmt.Sprintf(\"regular file mode must be 0644 or 0755 (got %o)\", mode))\n+\t\t}\n+\tcase tar.TypeSymlink:\n+\t\t// Symlink mode is NOT validated (Phase 7.6)\n+\t}\n+\n+\treturn nil\n+}\n+\n+func validateTarTime(name string, hdr *tar.Header, seenSec *int64) error {\n+\tts := hdr.ModTime\n+\tif ts.Nanosecond() != 0 {\n+\t\treturn NewVError(E_TIME, name, \"non-zero nanoseconds forbidden\")\n+\t}\n+\tif *seenSec == 0 {\n+\t\t*seenSec = ts.Unix()\n+\t} else {\n+\t\tif ts.Unix() != *seenSec {\n+\t\t\treturn NewVError(E_TIME, name, fmt.Sprintf(\"mtime mismatch (expected %d, got %d)\", *seenSec, ts.Unix()))\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func validateTarPAX(name string, hdr *tar.Header) error {\n+\tif len(hdr.PAXRecords) > 0 {\n+\t\tfor k := range hdr.PAXRecords {\n+\t\t\t// Phase 4.2: strict allowlist (path/linkpath only)\n+\t\t\tif k == \"path\" || k == \"linkpath\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif k == \"mtime\" || k == \"atime\" || k == \"ctime\" {\n+\t\t\t\treturn NewVError(E_PAX, name, \"forbidden PAX time key: \"+k)\n+\t\t\t}\n+\t\t\tif strings.HasPrefix(k, \"LIBARCHIVE.\") || strings.HasPrefix(k, \"SCHILY.xattr.\") {\n+\t\t\t\treturn NewVError(E_XATTR, name, \"xattr/provenance leak: \"+k)\n+\t\t\t}\n+\t\t\treturn NewVError(E_PAX, name, \"forbidden PAX key (not in allowlist): \"+k)\n+\t\t}\n+\t}\n+\tif len(hdr.Xattrs) > 0 {\n+\t\treturn NewVError(E_XATTR, name, \"xattr map present\")\n+\t}\n+\treturn nil\n+}\n+\n+func updateLayoutPresence(name string, hdr *tar.Header, rep *VerifyReport) {\n+\tswitch {\n+\tcase name == PathIndex:\n+\t\trep.HasIndex = true\n+\tcase name == PathContract:\n+\t\trep.HasContractJSON = true\n+\tcase name == PathSHA256SUMS:\n+\t\trep.HasSHA256SUMS = true\n+\tcase name == PathSHA256SUMSSeal:\n+\t\trep.HasSHA256SUMSSeal = true\n+\tcase name == PathSeriesPatch:\n+\t\trep.HasSeriesPatch = true\n+\tcase strings.HasPrefix(name, DirEvidence):\n+\t\tif hdr.Typeflag != tar.TypeDir {\n+\t\t\trep.EvidencePresent = true\n+\t\t}\n+\t}\n+}\n+\n+func processEntryContent(tr *tar.Reader, hdr *tar.Header, rep *VerifyReport) error {\n+\tif hdr.Typeflag == tar.TypeDir {\n+\t\treturn nil\n+\t}\n+\n+\tname := hdr.Name\n+\tvar hash [32]byte\n+\n+\tif hdr.Typeflag == tar.TypeSymlink {\n+\t\tif path.IsAbs(hdr.Linkname) || strings.Contains(hdr.Linkname, \"..\") {\n+\t\t\treturn NewVError(E_PATH, name, \"unsafe symlink target: \"+hdr.Linkname)\n+\t\t}\n+\t\tdata := []byte(\"symlink\\x00\" + hdr.Linkname)\n+\t\thash = sha256.Sum256(data)\n+\t} else {\n+\t\t// Regular file\n+\t\tisMeta := name == PathSHA256SUMS ||\n+\t\t\tname == PathSHA256SUMSSeal ||\n+\t\t\tname == PathContract ||\n+\t\t\tname == PathWarnings ||\n+\t\t\tstrings.HasPrefix(name, DirEvidence)\n+\n+\t\tif isMeta {\n+\t\t\t// Phase 7.5: 4MB limit for meta/evidence parsing\n+\t\t\tlr := io.LimitReader(tr, 4*1024*1024)\n+\t\t\tcontent, err := io.ReadAll(lr)\n+\t\t\tif err != nil {\n+\t\t\t\treturn WrapVError(E_GZIP, name, err)\n+\t\t\t}\n+\t\t\t// Check if we hit the limit\n+\t\t\tif int64(len(content)) == 4*1024*1024 {\n+\t\t\t\t// Peek one byte to see if there's more\n+\t\t\t\tvar b [1]byte\n+\t\t\t\tn, _ := tr.Read(b[:])\n+\t\t\t\tif n > 0 {\n+\t\t\t\t\t// We truncated. If it's evidence, we marks it as potentially incomplete/invalid for binding\n+\t\t\t\t\t// but we keep the truncated content for hash validation if it's already in SHA256SUMS.\n+\t\t\t\t\t// Actually, if it's truncated, SHA256 match will fail anyway if we hash the truncated bytes.\n+\t\t\t\t\t// The contract says: if >4MB, bound=false.\n+\t\t\t\t\tcontent = append(content, []byte(\"...[TRUNCATED]\")...)","path":"cmd/reviewbundle/verify.go","commit_id":"41a44446285de74eff61cdd07d2a3837665be82a","original_commit_id":"4039a3ec26070e218fdfb1f2a77ba461c47272ee","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The 4MB limit check has a logic flaw. After detecting truncation (n > 0 after reading 4MB), the code appends a \"[TRUNCATED]\" marker to the content. However, this modified content is then used to compute the SHA256 hash, which will never match the hash in SHA256SUMS (which was calculated from the original full content). This will cause validation to fail even though the issue is the file size, not corruption. Consider either: (1) failing immediately on oversized files with a clear E_LAYOUT error, or (2) skipping hash validation for truncated files and marking them specially in the report.\n```suggestion\n\t\t\t\t\t// The file exceeds the 4MB limit; treat this as a layout error rather than\n\t\t\t\t\t// hashing modified (truncated) content that cannot match SHA256SUMS.\n\t\t\t\t\treturn NewVError(E_LAYOUT, name, \"meta/evidence file exceeds 4MB limit\")\n```","created_at":"2026-02-16T14:15:26Z","updated_at":"2026-02-16T14:15:32Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644121","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644121"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644121"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644121/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":321,"start_side":"RIGHT","line":null,"original_line":325,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":325,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644150","pull_request_review_id":3808873517,"id":2812644150,"node_id":"PRRC_kwDOQkbgjc6npYs2","diff_hunk":"@@ -0,0 +1,173 @@\n+# PR verify report\n+\n+このレポートは `nix run .#prverify` の実行結果です。\n+\n+## Environment\n+\n+- timestamp (UTC): 20260216T133450Z\n+- git sha: 2c3b223\n+- rustc: rustc 1.92.0 (ded5c06cf 2025-12-08)\n+- cargo: cargo 1.92.0 (344c4567c 2025-10-21)\n+- go: go version go1.24.11 darwin/arm64\n+\n+## Commands\n+```bash\n+cargo test -p veil-cli --test cli_tests\n+cargo test --workspace\n+go run ./cmd/prverify\n+```\n+\n+## Drift Check (Go)\n+```\n+==> cargo test -p veil-cli --test cli_tests\n+    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.18s\n+     Running tests/cli_tests.rs (target/debug/deps/cli_tests-878ade359a526a3a)\n+\n+running 1 test\n+Testing tests/cmd/smoke_version.toml ... ok 965ms 83us 625ns\n+Testing tests/cmd/smoke_config_check.toml ... ok 1s 59ms 470us 125ns\n+Testing tests/cmd/smoke_filter.toml ... ok 1s 63ms 31us 542ns\n+Testing tests/cmd/help.toml ... ok 1s 63ms 136us 333ns\n+Testing tests/cmd/smoke_mask_dryrun.toml ... ok 1s 67ms 186us 667ns\n+Testing tests/cmd/smoke_scan_json.toml ... ok 1s 71ms 888us 583ns\n+test cli_tests ... ok\n+\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 1.07s\n+\n+==> cargo test --workspace\n+    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.22s\n+     Running unittests src/main.rs (target/debug/deps/veil-7b4d0451de6f73b2)\n+\n+running 13 tests\n+test commands::init::tests::test_build_config_standard ... ok\n+test formatters::json::tests::test_json_output ... ok\n+test formatters::markdown::tests::test_markdown_output ... ok\n+test commands::triage::tests::test_add_ignore_path_creates_structure ... ok\n+test commands::triage::tests::test_add_ignore_path_preserves_comments ... ok\n+ Severity | Score | Rule ID   | File     | Line | Match \n+----------+-------+-----------+----------+------+-------\n+ High     | 80    | test_rule | test.txt | 1    | 123 \n+test formatters::table::tests::test_table_output ... ok\n+test commands::exceptions::tests::test_system_registry_overrides_explicit ... ok\n+test commands::exceptions::tests::test_resolve_priority_explicit_path ... ok\n+test commands::exceptions::tests::test_resolve_priority_system_registry ... ok\n+test commands::exceptions::tests::test_resolve_priority_none ... ok\n+test commands::exceptions::tests::test_resolve_priority_repo_default_exists ... ok\n+test config_loader::tests::test_repo_only_config ... ok\n+test formatters::html::tests::test_html_generation ... ok\n+\n+test result: ok. 13 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.02s\n+\n+     Running tests/baseline_apply_test.rs (target/debug/deps/baseline_apply_test-7e3d30f590fa7262)\n+\n+running 2 tests\n+test test_baseline_error_conditions ... ok\n+test test_baseline_application_flow ... ok\n+\n+test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 1.40s\n+\n+     Running tests/baseline_error_test.rs (target/debug/deps/baseline_error_test-30c63ac0c6ac8caf)\n+\n+running 3 tests\n+test test_empty_baseline_file ... ok\n+test test_missing_baseline_file ... ok\n+test test_corrupt_baseline_file ... ok\n+\n+test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.15s\n+\n+     Running tests/baseline_test.rs (target/debug/deps/baseline_test-9166288074dd4ceb)\n+\n+running 2 tests\n+test baseline_argument_conflicts_with_write_baseline ... ok\n+test write_baseline_creates_file_with_schema ... ok\n+\n+test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.18s\n+\n+     Running tests/baseline_ux_test.rs (target/debug/deps/baseline_ux_test-fdf810b9feb8bae6)\n+\n+running 4 tests\n+test test_ux_case_a_clean ... ok\n+test test_ux_case_b_suppressed_clean ... ok\n+test test_ux_case_d_json_schema ... ok\n+test test_ux_case_c_dirty ... ok\n+\n+test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.42s\n+\n+     Running tests/binary_large_test.rs (target/debug/deps/binary_large_test-863f45d83fd229fa)\n+\n+running 1 test\n+test test_binary_and_large_files ... ok\n+\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.11s\n+\n+     Running tests/ci_flags_test.rs (target/debug/deps/ci_flags_test-a82a5b244150a824)\n+\n+running 2 tests\n+test test_fail_on_score ... ok\n+test test_fail_on_severity ... ok\n+\n+test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.44s\n+\n+     Running tests/cli_tests.rs (target/debug/deps/cli_tests-40d919cae03efb2e)\n+\n+running 1 test\n+Testing tests/cmd/smoke_version.toml ... ok 10ms 74us 750ns\n+Testing tests/cmd/help.toml ... ok 11ms 407us 959ns\n+Testing tests/cmd/smoke_config_check.toml ... ok 101ms 34us 875ns\n+Testing tests/cmd/smoke_filter.toml ... ok 105ms 472us 500ns\n+Testing tests/cmd/smoke_mask_dryrun.toml ... ok 106ms 100us 833ns\n+Testing tests/cmd/smoke_scan_json.toml ... ok 112ms 494us 833ns\n+test cli_tests ... ok\n+\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.11s\n+\n+     Running tests/config_dump_test.rs (target/debug/deps/config_dump_test-2e5f5f5ed57e5a75)\n+\n+running 6 tests\n+test config_dump_org_is_empty_by_default ... ok\n+test config_dump_org_env_explicit ... ok\n+test config_dump_user_xdg_implicit ... ok\n+test config_dump_toml_format ... ok\n+test config_dump_repo_and_effective_json ... ok\n+test config_layer_precedence ... ok\n+\n+test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.02s\n+\n+     Running tests/exceptions_flags_test.rs (target/debug/deps/exceptions_flags_test-f855c65e49c15b0e)\n+\n+running 3 tests\n+test test_system_registry_flag_is_boolean ... ok\n+test test_exceptions_flag_exclusivity ... ok\n+test test_exceptions_help_shows_all_flags ... ok\n+\n+test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s\n+\n+     Running tests/exit_code_test.rs (target/debug/deps/exit_code_test-1a59820895ab7604)\n+\n+running 1 test\n+test test_exit_code_behavior ... ok\n+\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.31s\n+\n+     Running tests/filter_config_test.rs (target/debug/deps/filter_config_test-6b767cacf0b97e01)\n+\n+running 4 tests\n+test test_filter_config_default_placeholder ... ok\n+test test_filter_config_rule_override ... ok\n+test test_filter_exit_code_zero ... ok\n+test test_filter_config_custom_placeholder ... ok\n+\n+test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.11s\n+\n+     Running tests/filter_rules_pack_test.rs (target/debug/deps/filter_rules_pack_test-cbd84b5d88cdac42)\n+\n+running 2 tests\n+test test_filter_load_rules_pack_jp ... ok\n+test test_filter_load_rules_pack ... ok\n+\n+test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.20s\n+\n+     Running tests/html_baseline_test.rs (target/debug/deps/html_baseline_test-27ce058bc33f90a7)\n+\n+running 1 test\n+signal: interrupt","path":"docs/evidence/prverify/prverify_20260216T133450Z_2c3b223.md","commit_id":"861ea41442259d138397665f9e13df7b80d7e3be","original_commit_id":"4039a3ec26070e218fdfb1f2a77ba461c47272ee","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"Two evidence files show \"signal: interrupt\" at the end, indicating the prverify process was interrupted before completion. These appear to be incomplete test runs that should not be committed as evidence. Consider removing prverify_20260216T133450Z_2c3b223.md and prverify_20260216T131734Z_bc52b29.md, keeping only the complete evidence file (prverify_20260216T140128Z_2546018.md).\n```suggestion\nsignal: interrupt (prverify run interrupted; this report is incomplete and must not be used as evidence)\n\n**Note:** The `prverify` execution corresponding to this file was interrupted before completion.\nA later run produced a complete report, which should be used instead of this incomplete log.\n```","created_at":"2026-02-16T14:15:26Z","updated_at":"2026-02-16T14:15:32Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644150","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644150"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644150"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644150/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":173,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":173,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644173","pull_request_review_id":3808873517,"id":2812644173,"node_id":"PRRC_kwDOQkbgjc6npYtN","diff_hunk":"@@ -0,0 +1,290 @@\n+package main\n+\n+import (\n+\t\"archive/tar\"\n+\t\"compress/gzip\"\n+\t\"crypto/sha256\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+func CreateBundleUI(mode, outDir string, stdout, stderr io.Writer) error {\n+\tepoch, err := ComputeEpochSec()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\theadSHA, err := getGitHeadSHA()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfmt.Fprintf(stdout, \"Creating bundle (mode=%s, epoch=%d, head=%s)\\n\", mode, epoch, headSHA[:12])\n+\n+\t// C4: Pre-checks\n+\tisDirty, err := isGitDirty()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif mode == ModeStrict {\n+\t\tif isDirty {\n+\t\t\treturn NewVError(E_CONTRACT, \"git\", \"repository is dirty (prohibited in strict mode)\")\n+\t\t}\n+\t\t// Evidence check will come in C5/C6\n+\t} else if mode == ModeWIP {\n+\t\tif isDirty {\n+\t\t\tfmt.Fprintln(stderr, \"WARN: repository is dirty\")\n+\t\t}\n+\t}\n+\n+\t// C4: contract.json generation\n+\tcontract := &Contract{\n+\t\tContractVersion: \"1.1\",\n+\t\tMode:            mode,\n+\t\tRepo:            \"veil-rs\", // Canonical\n+\t\tEpochSec:        epoch,\n+\t\tBaseRef:         \"main\", // Canonical entry","path":"cmd/reviewbundle/create.go","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"4039a3ec26070e218fdfb1f2a77ba461c47272ee","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The BaseRef is hardcoded as \"main\" instead of using the BASE_REF environment variable or accepting it as a parameter. This breaks backward compatibility with the legacy script which supported BASE_REF customization (defaulting to \"origin/main\"). Consider reading from environment or accepting as a parameter.\n```suggestion\n\tbaseRef := os.Getenv(\"BASE_REF\")\n\tif baseRef == \"\" {\n\t\tbaseRef = \"origin/main\"\n\t}\n\n\tcontract := &Contract{\n\t\tContractVersion: \"1.1\",\n\t\tMode:            mode,\n\t\tRepo:            \"veil-rs\", // Canonical\n\t\tEpochSec:        epoch,\n\t\tBaseRef:         baseRef,\n```","created_at":"2026-02-16T14:15:26Z","updated_at":"2026-02-16T14:15:32Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644173","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644173"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644173"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644173/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":50,"original_start_line":50,"start_side":"RIGHT","line":55,"original_line":55,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":55,"position":55,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644198","pull_request_review_id":3808873517,"id":2812644198,"node_id":"PRRC_kwDOQkbgjc6npYtm","diff_hunk":"@@ -0,0 +1,290 @@\n+package main\n+\n+import (\n+\t\"archive/tar\"\n+\t\"compress/gzip\"\n+\t\"crypto/sha256\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+func CreateBundleUI(mode, outDir string, stdout, stderr io.Writer) error {\n+\tepoch, err := ComputeEpochSec()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\theadSHA, err := getGitHeadSHA()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfmt.Fprintf(stdout, \"Creating bundle (mode=%s, epoch=%d, head=%s)\\n\", mode, epoch, headSHA[:12])\n+\n+\t// C4: Pre-checks\n+\tisDirty, err := isGitDirty()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif mode == ModeStrict {\n+\t\tif isDirty {\n+\t\t\treturn NewVError(E_CONTRACT, \"git\", \"repository is dirty (prohibited in strict mode)\")\n+\t\t}\n+\t\t// Evidence check will come in C5/C6\n+\t} else if mode == ModeWIP {\n+\t\tif isDirty {\n+\t\t\tfmt.Fprintln(stderr, \"WARN: repository is dirty\")\n+\t\t}\n+\t}\n+\n+\t// C4: contract.json generation\n+\tcontract := &Contract{\n+\t\tContractVersion: \"1.1\",\n+\t\tMode:            mode,\n+\t\tRepo:            \"veil-rs\", // Canonical\n+\t\tEpochSec:        epoch,\n+\t\tBaseRef:         \"main\", // Canonical entry\n+\t\tHeadSHA:         headSHA,\n+\t\tWarningsCount:   0,\n+\t\tEvidence: Evidence{\n+\t\t\tRequired:    mode == ModeStrict,\n+\t\t\tPresent:     false,\n+\t\t\tBoundToHead: false,\n+\t\t\tPathPrefix:  DirEvidence,\n+\t\t},\n+\t\tTool: Tool{\n+\t\t\tName:    \"reviewbundle\",\n+\t\t\tVersion: \"1.0.0\",\n+\t\t},\n+\t}\n+\n+\tif isDirty {\n+\t\tcontract.WarningsCount++\n+\t}\n+\n+\t// C5/C6: Actual bundle generation\n+\tpath, err := CreateBundle(contract, outDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfmt.Fprintf(stdout, \"Bundle created: %s\\n\", path)\n+\treturn nil\n+}\n+\n+func CreateBundle(c *Contract, outDir string) (string, error) {\n+\tif err := os.MkdirAll(outDir, 0755); err != nil {\n+\t\treturn \"\", WrapVError(E_PATH, outDir, err)\n+\t}\n+\n+\tts := time.Unix(c.EpochSec, 0).UTC().Format(\"20060102_150405\")\n+\tname := fmt.Sprintf(\"veil-rs_review_%s_%s_%s.tar.gz\", c.Mode, ts, c.HeadSHA[:12])","path":"cmd/reviewbundle/create.go","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"4039a3ec26070e218fdfb1f2a77ba461c47272ee","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The filename generation uses a fixed project name \"veil-rs\" instead of deriving it from the repository. This should use a dynamically determined project slug to maintain the \"repo-agnostic\" property. The legacy script computed this from the git toplevel directory basename.","created_at":"2026-02-16T14:15:27Z","updated_at":"2026-02-16T14:15:32Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644198","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644198"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644198"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644198/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":90,"original_line":90,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":90,"position":90,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644225","pull_request_review_id":3808873517,"id":2812644225,"node_id":"PRRC_kwDOQkbgjc6npYuB","diff_hunk":"@@ -0,0 +1,290 @@\n+package main\n+\n+import (\n+\t\"archive/tar\"\n+\t\"compress/gzip\"\n+\t\"crypto/sha256\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+func CreateBundleUI(mode, outDir string, stdout, stderr io.Writer) error {\n+\tepoch, err := ComputeEpochSec()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\theadSHA, err := getGitHeadSHA()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfmt.Fprintf(stdout, \"Creating bundle (mode=%s, epoch=%d, head=%s)\\n\", mode, epoch, headSHA[:12])\n+\n+\t// C4: Pre-checks\n+\tisDirty, err := isGitDirty()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif mode == ModeStrict {\n+\t\tif isDirty {\n+\t\t\treturn NewVError(E_CONTRACT, \"git\", \"repository is dirty (prohibited in strict mode)\")\n+\t\t}\n+\t\t// Evidence check will come in C5/C6\n+\t} else if mode == ModeWIP {\n+\t\tif isDirty {\n+\t\t\tfmt.Fprintln(stderr, \"WARN: repository is dirty\")\n+\t\t}\n+\t}\n+\n+\t// C4: contract.json generation\n+\tcontract := &Contract{\n+\t\tContractVersion: \"1.1\",\n+\t\tMode:            mode,\n+\t\tRepo:            \"veil-rs\", // Canonical\n+\t\tEpochSec:        epoch,\n+\t\tBaseRef:         \"main\", // Canonical entry\n+\t\tHeadSHA:         headSHA,\n+\t\tWarningsCount:   0,\n+\t\tEvidence: Evidence{\n+\t\t\tRequired:    mode == ModeStrict,\n+\t\t\tPresent:     false,\n+\t\t\tBoundToHead: false,\n+\t\t\tPathPrefix:  DirEvidence,\n+\t\t},\n+\t\tTool: Tool{\n+\t\t\tName:    \"reviewbundle\",\n+\t\t\tVersion: \"1.0.0\",\n+\t\t},\n+\t}\n+\n+\tif isDirty {\n+\t\tcontract.WarningsCount++\n+\t}\n+\n+\t// C5/C6: Actual bundle generation\n+\tpath, err := CreateBundle(contract, outDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfmt.Fprintf(stdout, \"Bundle created: %s\\n\", path)\n+\treturn nil\n+}\n+\n+func CreateBundle(c *Contract, outDir string) (string, error) {\n+\tif err := os.MkdirAll(outDir, 0755); err != nil {\n+\t\treturn \"\", WrapVError(E_PATH, outDir, err)\n+\t}\n+\n+\tts := time.Unix(c.EpochSec, 0).UTC().Format(\"20060102_150405\")\n+\tname := fmt.Sprintf(\"veil-rs_review_%s_%s_%s.tar.gz\", c.Mode, ts, c.HeadSHA[:12])\n+\toutPath := filepath.Join(outDir, name)\n+\n+\ttmpPath := outPath + \".tmp\"\n+\tf, err := os.Create(tmpPath)\n+\tif err != nil {\n+\t\treturn \"\", WrapVError(E_PATH, tmpPath, err)\n+\t}\n+\tdefer os.Remove(tmpPath)\n+\tdefer f.Close()\n+\n+\tgw := gzip.NewWriter(f)\n+\tgw.Header.ModTime = time.Unix(c.EpochSec, 0)\n+\tgw.Header.OS = 255\n+\tdefer gw.Close()\n+\n+\ttw := tar.NewWriter(gw)\n+\tdefer tw.Close()\n+\n+\t// 1. Gather files\n+\tfiles := make(map[string][]byte)\n+\n+\t// INDEX.md\n+\tfiles[PathIndex] = []byte(fmt.Sprintf(\"# Review Bundle\\n\\nMode: %s\\nEpoch: %d\\nHead: %s\\n\", c.Mode, c.EpochSec, c.HeadSHA))\n+\n+\t// patch/series.patch\n+\tpatch, err := getGitPatch(c.BaseRef, c.HeadSHA)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tfiles[PathSeriesPatch] = patch\n+\n+\t// Evidence (Phase 7.5/8/9)\n+\tbound, evFiles, err := collectEvidence(c.HeadSHA)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tif len(evFiles) > 0 {\n+\t\tc.Evidence.Present = true\n+\t\tc.Evidence.BoundToHead = bound\n+\t\tfor name, content := range evFiles {\n+\t\t\tfiles[name] = content\n+\t\t}\n+\t}\n+\n+\t// meta/contract.json (update with evidence findings)\n+\tcj, _ := json.MarshalIndent(c, \"\", \"  \")\n+\tfiles[PathContract] = cj\n+\n+\t// 2. Generate SHA256SUMS (C6)\n+\tvar manifestKeys []string\n+\tfor k := range files {\n+\t\tmanifestKeys = append(manifestKeys, k)\n+\t}\n+\tsort.Strings(manifestKeys)\n+\n+\tvar sumsBuilder strings.Builder\n+\tfor _, k := range manifestKeys {\n+\t\th := sha256.Sum256(files[k])\n+\t\tfmt.Fprintf(&sumsBuilder, \"%x  %s\\n\", h, k)\n+\t}\n+\tsums := []byte(sumsBuilder.String())\n+\tfiles[PathSHA256SUMS] = sums\n+\n+\t// seal\n+\tseal := sha256.Sum256(sums)\n+\tfiles[PathSHA256SUMSSeal] = []byte(fmt.Sprintf(\"%x  %s\\n\", seal, PathSHA256SUMS))\n+\n+\t// 3. Sort and write (C5)\n+\tvar keys []string\n+\tfor k := range files {\n+\t\tkeys = append(keys, k)\n+\t}\n+\tsort.Strings(keys)\n+\n+\tfor _, k := range keys {\n+\t\tcontent := files[k]\n+\t\thdr := &tar.Header{\n+\t\t\tName:     k,\n+\t\t\tSize:     int64(len(content)),\n+\t\t\tMode:     0644,\n+\t\t\tModTime:  time.Unix(c.EpochSec, 0),\n+\t\t\tTypeflag: tar.TypeReg,\n+\t\t\tUid:      0,\n+\t\t\tGid:      0,\n+\t\t\tUname:    \"\",\n+\t\t\tGname:    \"\",\n+\t\t\tFormat:   tar.FormatPAX,\n+\t\t\t// Phase 4.2/7.3: Explicitly zero extra times to avoid PAX mtime/atime/ctime\n+\t\t\tAccessTime: time.Time{},\n+\t\t\tChangeTime: time.Time{},\n+\t\t\tPAXRecords: nil,\n+\t\t}\n+\t\tif err := tw.WriteHeader(hdr); err != nil {\n+\t\t\treturn \"\", WrapVError(E_GZIP, k, err)\n+\t\t}\n+\t\tif _, err := tw.Write(content); err != nil {\n+\t\t\treturn \"\", WrapVError(E_GZIP, k, err)\n+\t\t}\n+\t}\n+\n+\ttw.Close()\n+\tgw.Close()\n+\tf.Close()\n+\n+\tif err := os.Rename(tmpPath, outPath); err != nil {\n+\t\treturn \"\", WrapVError(E_PATH, outPath, err)\n+\t}\n+\n+\t// 4. Self-Audit (C6)\n+\t_, err = VerifyBundlePath(outPath)\n+\tif err != nil {\n+\t\t// If verification fails, we keep the broken bundle for inspection but return error\n+\t\treturn outPath, fmt.Errorf(\"self-audit failed for %s: %w\", outPath, err)\n+\t}\n+\n+\treturn outPath, nil\n+}\n+\n+func getGitPatch(base, head string) ([]byte, error) {\n+\tout, err := exec.Command(\"git\", \"format-patch\", \"--stdout\", base+\"..\"+head).Output()\n+\tif err != nil {\n+\t\treturn nil, WrapVError(E_CONTRACT, \"git format-patch\", err)","path":"cmd/reviewbundle/create.go","commit_id":"3be0b5303f4604246b14cad24fbd804770ba84a9","original_commit_id":"4039a3ec26070e218fdfb1f2a77ba461c47272ee","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The git command is executed without error output being captured. If the patch generation fails, the error message from git will not be included in the VError detail, making it harder to debug. Consider using CombinedOutput() instead of Output() to capture stderr.\n```suggestion\n\tout, err := exec.Command(\"git\", \"format-patch\", \"--stdout\", base+\"..\"+head).CombinedOutput()\n\tif err != nil {\n\t\tdetail := fmt.Sprintf(\"git format-patch %s..%s: %s\", base, head, strings.TrimSpace(string(out)))\n\t\treturn nil, WrapVError(E_CONTRACT, detail, err)\n```","created_at":"2026-02-16T14:15:27Z","updated_at":"2026-02-16T14:15:32Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644225","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644225"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644225"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644225/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":210,"start_side":"RIGHT","line":null,"original_line":212,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":212,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644254","pull_request_review_id":3808873517,"id":2812644254,"node_id":"PRRC_kwDOQkbgjc6npYue","diff_hunk":"@@ -0,0 +1,50 @@\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"os\"\n+\t\"strconv\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func TestVerify_DeterministicResultForSameInput(t *testing.T) {\n+\t// TODO: implement in C3/C5\n+}\n+\n+func TestCreate_Determinism(t *testing.T) {\n+\tepoch := int64(1700000000)\n+\tos.Setenv(\"SOURCE_DATE_EPOCH\", strconv.FormatInt(epoch, 10))\n+\tdefer os.Unsetenv(\"SOURCE_DATE_EPOCH\")\n+\n+\theadSHA, _ := getGitHeadSHA()","path":"cmd/reviewbundle/determinism_test.go","commit_id":"3be0b5303f4604246b14cad24fbd804770ba84a9","original_commit_id":"4039a3ec26070e218fdfb1f2a77ba461c47272ee","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The test ignores the error from getGitHeadSHA. If the function fails, headSHA will be an empty string, which will cause the test to create invalid bundles. Add error handling to skip or fail the test gracefully if git operations fail.\n```suggestion\n\theadSHA, err := getGitHeadSHA()\n\tif err != nil {\n\t\tt.Fatalf(\"failed to get git HEAD SHA: %v\", err)\n\t}\n\tif headSHA == \"\" {\n\t\tt.Fatalf(\"failed to get git HEAD SHA: got empty SHA\")\n\t}\n```","created_at":"2026-02-16T14:15:27Z","updated_at":"2026-02-16T14:15:33Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644254","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644254"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644254"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644254/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":20,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":20,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644276","pull_request_review_id":3808873517,"id":2812644276,"node_id":"PRRC_kwDOQkbgjc6npYu0","diff_hunk":"@@ -0,0 +1,101 @@\n+# REVIEW BUNDLE CONTRACT v1.1\n+\n+## 1. Mission & Philosophy\n+Review Bundle は「監査に耐える契約成果物 (contract artifact)」である。\n+作成ツール (go / bash) によらず、同一入力からは常に同一の bundle (byte-identical) が生成されなければならない。\n+また、verify コマンドは bundle の内容のみから正当性を証明できなければならない。\n+\n+## 2. Canonical Structure (Layout)\n+Bundle MUST be a `.tar.gz` file containing the following structure:\n+\n+- `review/INDEX.md` : Human-readable summary\n+- `review/meta/contract.json` : Machine-readable metadata (version, mode, base/head, epoch, counts)\n+- `review/meta/SHA256SUMS` : Checksums of all files (excluding itself)\n+- `review/meta/SHA256SUMS.sha256` : Checksum of SHA256SUMS\n+- `review/patch/series.patch` : Full patch from base to head\n+- `review/evidence/**` : Proof of verification (strict mode: required)\n+- `review/files/**` : Source file snapshots\n+\n+## 3. Determinism Rules (MUST)\n+Output MUST be reproducible bit-for-bit given the same:\n+- Git references (HEAD, Base)\n+- Epoch timestamp (SOURCE_DATE_EPOCH or HEAD commit time)\n+\n+### 3.1. Timestamp Normalization\n+- **Epoch Source**:\n+  - If `SOURCE_DATE_EPOCH` env var is set, use it.\n+  - Else, use git HEAD commit time (`%ct`).\n+- **Gzip Header**:\n+  - ModTime = Epoch (matches source)\n+  - OS = 255 (unknown)\n+  - Name/Comment = Empty\n+- **Tar Header**:\n+  - MTime = Epoch (matches source)\n+  - AccessTime / ChangeTime MUST be zero (epoch 0) or omitted.\n+  - PAX atime/ctime/mtime MUST NOT appear in the archive.\n+\n+### 3.2. Entry Ordering\n+- All entries in the tarball MUST be sorted by their full path in **bytewise lexicographic order**.\n+\n+### 3.3. Identity Anonymization (No Host Leak)\n+- **User/Group**:\n+  - UID = 0\n+  - GID = 0\n+  - Uname = \"\" (empty)\n+  - Gname = \"\" (empty)\n+- **Permissions (Mode)**:\n+  - Directory = `0755`\n+  - Regular File = `0644`\n+  - Executable Regular File = `0755`\n+  - Symlink = (Not validated; implementation dependent)\n+- **Extended Attributes / PAX**:\n+  - **PAX Records**: Only `path` and `linkpath` keys are permitted.\n+  - **Forbidden PAX Keys**: `mtime`, `atime`, `ctime` MUST NOT be present.\n+  - **Forbidden Xattrs**: `LIBARCHIVE.*`, `SCHILY.xattr.*`, or any other extended attributes MUST NOT be present.\n+  - Verification MUST fail if any forbidden or unknown keys are found.\n+- **Paths**:\n+  - Absolute paths MUST NOT be present.\n+  - `../` (parent traversal) MUST NOT be present.\n+\n+## 4. Checksumming Rules (MUST)\n+Output MUST be verifiable via SHA256:\n+\n+- **Regular File**: `sha256(file_content_bytes)`\n+- **Symlink**: `sha256(\"symlink\\x00\" + target_path)`\n+- **Directory**: (Not checksummed individually; included in manifest via layout if needed)\n+\n+## 4. Evidence Binding\n+- **Strict Mode**:\n+  - Repository MUST be clean.\n+  - Evidence file (`docs/evidence/prverify/prverify_*.md`) bound to HEAD or ANCHOR MUST exist.\n+  - The evidence MUST be included in `review/evidence/`.\n+  - Fallback to \"latest available\" is PROHIBITED.\n+- **WIP Mode**:\n+  - Repository MAY be dirty.\n+  - Evidence MAY be missing.\n+  - If missing, a warning MUST be recorded in `review/meta/warnings.txt`.\n+\n+## 5. Manifest & Integrity\n+- **SHA256SUMS**:\n+  - MUST list SHA256 hashes for all files in the bundle except `review/meta/SHA256SUMS` and `review/meta/SHA256SUMS.sha256`.\n+  - Format: `hash  path` (standard sha256sum format).\n+  - Path MUST be relative to the bundle root (e.g., `review/INDEX.md`).\n+- **SHA256SUMS.sha256**:\n+  - MUST contain the single SHA256 hash of `review/meta/SHA256SUMS`.\n+  - This \"seals\" the bundle manifest.\n+- **Symlink Checksums**:\n+  - For symlinks, the checksum in `SHA256SUMS` MUST be `sha256(\"symlink\\x00\" + target)`.\n+\n+## 6. Verification Protocol (verify command)\n+A valid verify run involves:\n+1. **Structure Check**: Confirm required files exist.\n+2. **Leak Check**: Scan tar headers for non-zero UIDs, known xattr keys, or absolute paths.\n+3. **Integrity Check**:\n+   - Verify `review/meta/SHA256SUMS` against `review/meta/SHA256SUMS.sha256`.\n+   - Verify every file in the bundle matches the hash in `SHA256SUMS`.\n+4. **Contract Check**:\n+   - `contract.json` version matches tool capability.\n+   - If `mode=strict`, ensure evidence is present.\n+\n+## 7. Versioning\n+- This document defines Contract Version: `v1.1`","path":"docs/ops/REVIEW_BUNDLE.md","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"4039a3ec26070e218fdfb1f2a77ba461c47272ee","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The documentation title uses \"v1.1\" but the final line uses backticks around \"v1.1\" which will render as code formatting. For consistency with the title, remove the backticks to render it as plain text: \"This document defines Contract Version: v1.1\"\n```suggestion\n- This document defines Contract Version: v1.1\n```","created_at":"2026-02-16T14:15:27Z","updated_at":"2026-02-16T14:15:33Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644276","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644276"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644276"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644276/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":101,"original_line":101,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":101,"position":101,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644294","pull_request_review_id":3808873517,"id":2812644294,"node_id":"PRRC_kwDOQkbgjc6npYvG","diff_hunk":"@@ -0,0 +1,101 @@\n+# REVIEW BUNDLE CONTRACT v1.1\n+\n+## 1. Mission & Philosophy\n+Review Bundle は「監査に耐える契約成果物 (contract artifact)」である。\n+作成ツール (go / bash) によらず、同一入力からは常に同一の bundle (byte-identical) が生成されなければならない。\n+また、verify コマンドは bundle の内容のみから正当性を証明できなければならない。\n+\n+## 2. Canonical Structure (Layout)\n+Bundle MUST be a `.tar.gz` file containing the following structure:\n+\n+- `review/INDEX.md` : Human-readable summary\n+- `review/meta/contract.json` : Machine-readable metadata (version, mode, base/head, epoch, counts)\n+- `review/meta/SHA256SUMS` : Checksums of all files (excluding itself)\n+- `review/meta/SHA256SUMS.sha256` : Checksum of SHA256SUMS\n+- `review/patch/series.patch` : Full patch from base to head\n+- `review/evidence/**` : Proof of verification (strict mode: required)\n+- `review/files/**` : Source file snapshots\n+\n+## 3. Determinism Rules (MUST)\n+Output MUST be reproducible bit-for-bit given the same:\n+- Git references (HEAD, Base)\n+- Epoch timestamp (SOURCE_DATE_EPOCH or HEAD commit time)\n+\n+### 3.1. Timestamp Normalization\n+- **Epoch Source**:\n+  - If `SOURCE_DATE_EPOCH` env var is set, use it.\n+  - Else, use git HEAD commit time (`%ct`).\n+- **Gzip Header**:\n+  - ModTime = Epoch (matches source)\n+  - OS = 255 (unknown)\n+  - Name/Comment = Empty\n+- **Tar Header**:\n+  - MTime = Epoch (matches source)\n+  - AccessTime / ChangeTime MUST be zero (epoch 0) or omitted.\n+  - PAX atime/ctime/mtime MUST NOT appear in the archive.\n+\n+### 3.2. Entry Ordering\n+- All entries in the tarball MUST be sorted by their full path in **bytewise lexicographic order**.\n+\n+### 3.3. Identity Anonymization (No Host Leak)\n+- **User/Group**:\n+  - UID = 0\n+  - GID = 0\n+  - Uname = \"\" (empty)\n+  - Gname = \"\" (empty)\n+- **Permissions (Mode)**:\n+  - Directory = `0755`\n+  - Regular File = `0644`\n+  - Executable Regular File = `0755`\n+  - Symlink = (Not validated; implementation dependent)\n+- **Extended Attributes / PAX**:\n+  - **PAX Records**: Only `path` and `linkpath` keys are permitted.\n+  - **Forbidden PAX Keys**: `mtime`, `atime`, `ctime` MUST NOT be present.\n+  - **Forbidden Xattrs**: `LIBARCHIVE.*`, `SCHILY.xattr.*`, or any other extended attributes MUST NOT be present.\n+  - Verification MUST fail if any forbidden or unknown keys are found.\n+- **Paths**:\n+  - Absolute paths MUST NOT be present.\n+  - `../` (parent traversal) MUST NOT be present.\n+\n+## 4. Checksumming Rules (MUST)\n+Output MUST be verifiable via SHA256:\n+\n+- **Regular File**: `sha256(file_content_bytes)`\n+- **Symlink**: `sha256(\"symlink\\x00\" + target_path)`\n+- **Directory**: (Not checksummed individually; included in manifest via layout if needed)\n+\n+## 4. Evidence Binding","path":"docs/ops/REVIEW_BUNDLE.md","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"4039a3ec26070e218fdfb1f2a77ba461c47272ee","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"Section 4 \"Checksumming Rules\" appears twice - once for checksumming rules and once for evidence binding. The second section 4 should be renumbered to section 5, and all subsequent sections should be renumbered accordingly (current sections 5, 6, 7 should become 6, 7, 8).","created_at":"2026-02-16T14:15:28Z","updated_at":"2026-02-16T14:15:33Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644294","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644294"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644294"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644294/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":67,"original_line":67,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":67,"position":67,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644316","pull_request_review_id":3808873517,"id":2812644316,"node_id":"PRRC_kwDOQkbgjc6npYvc","diff_hunk":"@@ -33,10 +34,9 @@ All PRs starting from S11-00 MUST update this file (at least the % and \"Last Upd\n - Date: 2026-02-16 (+0900)\n - By: @mt4110\n - Agent: @antigravity\n-- Evidence: docs/evidence/prverify/prverify_20260216T085628Z_93bd2c3.md\n+- Evidence: docs/evidence/prverify/prverify_20260216T133450Z_2c3b223.md","path":"docs/ops/STATUS.md","commit_id":"4039a3ec26070e218fdfb1f2a77ba461c47272ee","original_commit_id":"4039a3ec26070e218fdfb1f2a77ba461c47272ee","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The Evidence field references \"prverify_20260216T133450Z_2c3b223.md\", but this file shows \"signal: interrupt\" indicating an incomplete test run. The STATUS.md should reference the complete evidence file \"prverify_20260216T140128Z_2546018.md\" instead.\n```suggestion\n- Evidence: docs/evidence/prverify/prverify_20260216T140128Z_2546018.md\n```","created_at":"2026-02-16T14:15:28Z","updated_at":"2026-02-16T14:15:33Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644316","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644316"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644316"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644316/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":37,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":16,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644339","pull_request_review_id":3808873517,"id":2812644339,"node_id":"PRRC_kwDOQkbgjc6npYvz","diff_hunk":"@@ -0,0 +1,50 @@\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"os\"\n+\t\"strconv\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func TestVerify_DeterministicResultForSameInput(t *testing.T) {\n+\t// TODO: implement in C3/C5\n+}\n+\n+func TestCreate_Determinism(t *testing.T) {\n+\tepoch := int64(1700000000)\n+\tos.Setenv(\"SOURCE_DATE_EPOCH\", strconv.FormatInt(epoch, 10))\n+\tdefer os.Unsetenv(\"SOURCE_DATE_EPOCH\")\n+\n+\theadSHA, _ := getGitHeadSHA()\n+\tc := &Contract{\n+\t\tContractVersion: \"1.1\",\n+\t\tMode:            \"wip\",\n+\t\tRepo:            \"veil-rs\",\n+\t\tEpochSec:        epoch,\n+\t\tBaseRef:         \"main\",\n+\t\tHeadSHA:         headSHA,\n+\t\tTool:            Tool{Name: \"test\", Version: \"0.0.0\"},\n+\t}\n+\n+\toutDir := t.TempDir()\n+\tpath1, err := CreateBundle(c, outDir)\n+\tif err != nil {\n+\t\tt.Fatalf(\"First create failed: %v\", err)\n+\t}\n+\tb1, _ := os.ReadFile(path1)\n+\n+\t// Sleep to ensure time doesn't leak if we had a bug\n+\ttime.Sleep(10 * time.Millisecond)\n+\n+\tpath2, err := CreateBundle(c, outDir)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Second create failed: %v\", err)\n+\t}\n+\tb2, _ := os.ReadFile(path2)","path":"cmd/reviewbundle/determinism_test.go","commit_id":"3be0b5303f4604246b14cad24fbd804770ba84a9","original_commit_id":"4039a3ec26070e218fdfb1f2a77ba461c47272ee","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The test ignores errors from os.ReadFile. If the file read fails, b1 or b2 will be nil and the comparison will incorrectly pass (both nil). Add error handling to fail the test if ReadFile returns an error.","created_at":"2026-02-16T14:15:28Z","updated_at":"2026-02-16T14:15:33Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644339","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644339"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644339"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644339/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":36,"start_side":"RIGHT","line":null,"original_line":45,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":45,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644372","pull_request_review_id":3808873517,"id":2812644372,"node_id":"PRRC_kwDOQkbgjc6npYwU","diff_hunk":"@@ -0,0 +1,118 @@\n+package main\n+\n+import (\n+\t\"bufio\"\n+\t\"bytes\"\n+\t\"crypto/sha256\"\n+\t\"encoding/hex\"\n+\t\"fmt\"\n+\t\"strings\"\n+)\n+\n+type ChecksumLine struct {\n+\tPath string\n+\tSum  [32]byte\n+}\n+\n+func ParseSHA256SUMS(b []byte) ([]ChecksumLine, error) {\n+\tvar lines []ChecksumLine\n+\tscanner := bufio.NewScanner(bytes.NewReader(b))\n+\tfor scanner.Scan() {\n+\t\tline := scanner.Text()\n+\t\tif line == \"\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\t// Format: \"hash  path\" (two spaces)\n+\t\tparts := strings.SplitN(line, \"  \", 2)\n+\t\tif len(parts) != 2 {\n+\t\t\treturn nil, NewVError(E_SHA256, \"SHA256SUMS\", \"invalid format\")\n+\t\t}\n+\t\tsumHex := parts[0]\n+\t\tpath := parts[1]\n+\n+\t\tsum, err := ParseSHA256HexLine([]byte(sumHex))\n+\t\tif err != nil {\n+\t\t\treturn nil, NewVError(E_SHA256, \"SHA256SUMS\", \"invalid hex: \"+sumHex)\n+\t\t}\n+\t\tlines = append(lines, ChecksumLine{Path: path, Sum: sum})\n+\t}\n+\tif err := scanner.Err(); err != nil {\n+\t\treturn nil, WrapVError(E_SHA256, \"SHA256SUMS\", err)\n+\t}\n+\treturn lines, nil\n+}\n+\n+func ParseSHA256HexLine(b []byte) ([32]byte, error) {\n+\tvar sum [32]byte\n+\tif len(b) != 64 {\n+\t\treturn sum, fmt.Errorf(\"invalid length: %d\", len(b))\n+\t}\n+\t_, err := hex.Decode(sum[:], b)\n+\treturn sum, err\n+}\n+\n+func VerifySHA256SUMSSeal(sums []byte, seal []byte) error {\n+\t// Seal is just the hex string of sha256(sums)\n+\t// Expected seal content: \"hexhash  review/meta/SHA256SUMS\\n\" ??\n+\t// Or just the hash?\n+\t// Contract says: \"SHA256SUMS.sha256 contains the signed sha256 of SHA256SUMS\"\n+\t// S11-03 PLAN says: \"SHA256SUMS.sha256 を生成（封印）\"\n+\t// Typically this is `sha256sum SHA256SUMS > SHA256SUMS.sha256`\n+\t// So it matches standard format: \"hash  filename\\n\"\n+\n+\tactualHash := sha256.Sum256(sums)\n+\n+\t// Parse the seal file\n+\tlines, err := ParseSHA256SUMS(seal)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif len(lines) != 1 {\n+\t\treturn NewVError(E_SHA256, \"SHA256SUMS.sha256\", \"must contain exactly one line\")\n+\t}\n+\n+\tif lines[0].Path != \"review/meta/SHA256SUMS\" {\n+\t\t// Tolerable? Standard sha256sum output includes filename.\n+\t\t// Contract says \"review/meta/SHA256SUMS\" is the name.\n+\t\t// If generated from root, it might be that.\n+\t\t// Let's enforce it matches.\n+\t\tif !strings.HasSuffix(lines[0].Path, \"SHA256SUMS\") {\n+\t\t\treturn NewVError(E_SHA256, \"SHA256SUMS.sha256\", \"unexpected filename in seal: \"+lines[0].Path)\n+\t\t}","path":"cmd/reviewbundle/checksums.go","commit_id":"41a44446285de74eff61cdd07d2a3837665be82a","original_commit_id":"4039a3ec26070e218fdfb1f2a77ba461c47272ee","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The suffix check for \"SHA256SUMS\" is too permissive. It will accept paths like \"review/meta/BADSHA256SUMS\" or \"FAKESUMS/SHA256SUMS\" when the exact path should be \"review/meta/SHA256SUMS\". Consider using exact path comparison or checking that the path ends with \"/SHA256SUMS\" to prevent accepting malformed seal files.\n```suggestion\n\tif lines[0].Path != \"review/meta/SHA256SUMS\" && lines[0].Path != \"SHA256SUMS\" {\n\t\t// Standard sha256sum output includes the filename.\n\t\t// Contract says \"review/meta/SHA256SUMS\" is the name.\n\t\t// If generated from the bundle root, it might just be \"SHA256SUMS\".\n\t\t// Enforce that the seal refers exactly to one of these expected names.\n\t\treturn NewVError(E_SHA256, \"SHA256SUMS.sha256\", \"unexpected filename in seal: \"+lines[0].Path)\n```","created_at":"2026-02-16T14:15:29Z","updated_at":"2026-02-16T14:15:33Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644372","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644372"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644372"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644372/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":74,"start_side":"RIGHT","line":null,"original_line":81,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":81,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644397","pull_request_review_id":3808873517,"id":2812644397,"node_id":"PRRC_kwDOQkbgjc6npYwt","diff_hunk":"@@ -0,0 +1,57 @@\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+func main() {\n+\tos.Exit(run(os.Args, os.Stdout, os.Stderr))\n+}\n+\n+func run(argv []string, stdout, stderr io.Writer) int {\n+\tif len(argv) < 2 {\n+\t\tusage(stderr)\n+\t\treturn 1\n+\t}\n+\n+\tcmd := argv[1]\n+\tswitch cmd {\n+\tcase \"verify\":\n+\t\tif len(argv) < 3 {\n+\t\t\tfmt.Fprintln(stderr, \"error: verify requires bundle path\")\n+\t\t\tusage(stderr)\n+\t\t\treturn 1\n+\t\t}\n+\t\tpath := argv[2]\n+\t\treport, err := VerifyBundlePath(path)\n+\t\tif err != nil {\n+\t\t\tfmt.Fprintln(stderr, err.Error())\n+\t\t\treturn 1\n+\t\t}\n+\t\tfmt.Fprintf(stdout, \"PASS: %s (mode=%s, epoch=%d)\\n\", path, report.Contract.Mode, report.Contract.EpochSec)\n+\t\treturn 0\n+\n+\tcase \"create\":\n+\t\t// TODO: flags for mode/out-dir\n+\t\tmode := \"wip\"\n+\t\toutDir := \".local/review-bundles\"\n+\t\tif err := CreateBundleUI(mode, outDir, stdout, stderr); err != nil {\n+\t\t\tfmt.Fprintln(stderr, err.Error())\n+\t\t\treturn 1\n+\t\t}\n+\t\treturn 0","path":"cmd/reviewbundle/main.go","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"4039a3ec26070e218fdfb1f2a77ba461c47272ee","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The create command hardcodes mode as \"wip\" and outDir as \".local/review-bundles\", ignoring environment variables MODE and OUT_DIR that were supported by the legacy bash script. This breaks backward compatibility. Consider reading these from environment variables or adding command-line flags to maintain compatibility.","created_at":"2026-02-16T14:15:29Z","updated_at":"2026-02-16T14:15:33Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644397","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644397"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644397"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644397/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":37,"original_start_line":36,"start_side":"RIGHT","line":71,"original_line":44,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":44,"position":71,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644423","pull_request_review_id":3808873517,"id":2812644423,"node_id":"PRRC_kwDOQkbgjc6npYxH","diff_hunk":"@@ -56,6 +56,15 @@\n           '';\n         };\n \n+        # Review Bundle CLI\n+        reviewbundlePkg = pkgs.buildGoModule {\n+          pname = \"reviewbundle\";\n+          version = \"1.0.0\";\n+          src = ./.;\n+          subPackages = [ \"cmd/reviewbundle\" ];\n+          vendorHash = null;","path":"flake.nix","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"4039a3ec26070e218fdfb1f2a77ba461c47272ee","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The buildGoModule is missing a go.mod file check. With vendorHash = null, the build expects vendored dependencies or no dependencies. However, the codebase has a go.mod with dependencies (go-toml). Consider either: (1) setting vendorHash to a proper hash value, or (2) using vendorHash = lib.fakeSha256 initially to get the correct hash from the build error, then updating with the real hash.","created_at":"2026-02-16T14:15:29Z","updated_at":"2026-02-16T14:15:33Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644423","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644423"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644423"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644423/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":60,"original_start_line":60,"start_side":"RIGHT","line":65,"original_line":65,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":10,"position":10,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644451","pull_request_review_id":3808873517,"id":2812644451,"node_id":"PRRC_kwDOQkbgjc6npYxj","diff_hunk":"@@ -1,261 +1,14 @@\n #!/usr/bin/env bash\n set -euo pipefail\n \n-# Review bundle generator (repo-agnostic / deterministic-ish / human-friendly)\n-#\n-# Modes:\n-#   MODE=clean (default): requires clean working tree; bundles committed range base..HEAD\n-#   MODE=wip             : allows dirty tree; also bundles staged/unstaged/untracked changes\n-#\n-# Output:\n-#   default OUT_DIR: .local/review-bundles (inside repo toplevel)\n-#\n-# Optional extra include list:\n-#   INCLUDE_FILE (default): .review-bundle.include\n-#   - one pathspec per line (supports simple globs like docs/runbook/*.md)\n-#   - blank lines and comments (# ...) are ignored\n-#\n-# Evidence:\n-#   - If EVIDENCE_FILE is set, it is included (absolute or relative to repo root)\n-#   - Otherwise auto-detect .local/prverify:\n-#       1) Prefer logs matching HEAD (12 or 7 short SHA)\n-#       2) Fallback to latest prverify_*.md with a warning trail\n-#\n-# Usage (from repo root):\n-#   bash ops/review_bundle.sh\n-#   MODE=wip bash ops/review_bundle.sh\n-#\n-# Optional:\n-#   REPO=../some-repo BASE_REF=origin/main OUT_DIR=.local/review-bundles MODE=wip bash ops/review_bundle.sh\n+# Shim for the new Go implementation (S11-03)\n+# Translates legacy environment variables to the new Go tool.\n \n-repo=\"${REPO:-.}\"\n-BASE_REF=\"${BASE_REF:-origin/main}\"\n-MODE=\"${MODE:-clean}\"\n+MODE=\"${MODE:-wip}\"\n OUT_DIR=\"${OUT_DIR:-.local/review-bundles}\"\n-INCLUDE_FILE=\"${INCLUDE_FILE:-.review-bundle.include}\"\n-ts=\"$(date +'%Y%m%d_%H%M%S')\"\n \n-cleanup() {\n-  if [ -n \"${tmp:-}\" ] && [ -d \"${tmp:-}\" ]; then\n-    rm -rf \"$tmp\"\n-  fi\n-}\n-trap cleanup EXIT\n+# Ensure we use Go 1.24\n+export GOTOOLCHAIN=local\n \n-if [ \"$MODE\" != \"clean\" ] && [ \"$MODE\" != \"wip\" ]; then\n-  echo \"ERROR: MODE must be 'clean' or 'wip' (got: $MODE)\" >&2\n-  exit 1\n-fi\n-\n-toplevel=\"$(git -C \"$repo\" rev-parse --show-toplevel)\"\n-project=\"$(basename \"$toplevel\")\"\n-project_slug=\"$(printf \"%s\" \"$project\" | tr -c 'A-Za-z0-9._-' '_' )\"\n-\n-# Clean requirement only for MODE=clean\n-if [ \"$MODE\" = \"clean\" ]; then\n-  if [ -n \"$(git -C \"$toplevel\" status --porcelain=v1)\" ]; then\n-    echo \"ERROR: working tree is not clean. Commit or stash (including untracked) for deterministic bundle.\" >&2\n-    echo \"Hint: run 'MODE=wip bash ops/review_bundle.sh' for pre-commit review.\" >&2\n-    exit 1\n-  fi\n-fi\n-\n-head12=\"$(git -C \"$toplevel\" rev-parse --short=12 HEAD)\"\n-head7=\"$(git -C \"$toplevel\" rev-parse --short=7 HEAD)\"\n-# Anchor (last non-doc commit) for evidence stability\n-anchor_sha=\"$(git -C \"$toplevel\" log -1 --format=%H -- . ':(exclude)docs/**' 2>/dev/null || git -C \"$toplevel\" rev-parse HEAD)\"\n-anchor7=\"$(printf \"%s\" \"$anchor_sha\" | cut -c1-7)\"\n-\n-# Resolve base (fallback chain)\n-if git -C \"$toplevel\" rev-parse --verify -q \"$BASE_REF\" >/dev/null; then\n-  base=\"$(git -C \"$toplevel\" merge-base HEAD \"$BASE_REF\")\"\n-elif git -C \"$toplevel\" rev-parse --verify -q main >/dev/null; then\n-  base=\"$(git -C \"$toplevel\" merge-base HEAD main)\"\n-else\n-  base=\"$(git -C \"$toplevel\" merge-base HEAD master)\"\n-fi\n-\n-suffix=\"\"\n-if [ \"$MODE\" = \"wip\" ]; then\n-  suffix=\"_wip\"\n-fi\n-\n-# output dir (absolute or relative to repo root)\n-case \"$OUT_DIR\" in\n-  /*) out_dir=\"$OUT_DIR\" ;;\n-  *)  out_dir=\"$toplevel/$OUT_DIR\" ;;\n-esac\n-mkdir -p \"$out_dir\"\n-\n-out=\"$out_dir/${project_slug}_review${suffix}_${ts}_${head12}.tar.gz\"\n-\n-tmp=\"$(mktemp -d)\"\n-root=\"$tmp/review\"\n-mkdir -p \"$root/meta\" \"$root/patch\" \"$root/files\" \"$root/evidence\"\n-\n-# Always create warnings.txt so reviewers can rely on it existing.\n-: > \"$root/meta/warnings.txt\"\n-\n-# --- META ---\n-git -C \"$toplevel\" rev-parse HEAD > \"$root/meta/head_sha.txt\"\n-echo \"$base\" > \"$root/meta/base_sha.txt\"\n-git -C \"$toplevel\" rev-parse --abbrev-ref HEAD > \"$root/meta/branch.txt\"\n-git -C \"$toplevel\" status --porcelain=v1 > \"$root/meta/status.txt\"\n-echo \"$MODE\" > \"$root/meta/mode.txt\"\n-echo \"$BASE_REF\" > \"$root/meta/base_ref.txt\"\n-echo \"$OUT_DIR\" > \"$root/meta/out_dir.txt\"\n-echo \"$project\" > \"$root/meta/project.txt\"\n-\n-git -C \"$toplevel\" show -s --format='commit=%H%nshort=%h%ndate=%cI%nauthor=%an <%ae>%nsubject=%s' HEAD \\\n-  > \"$root/meta/head_commit.txt\"\n-\n-git -C \"$toplevel\" diff --stat \"$base..HEAD\" > \"$root/meta/diff_stat_committed.txt\"\n-git -C \"$toplevel\" diff --name-status \"$base..HEAD\" > \"$root/meta/name_status_committed.txt\"\n-\n-if [ \"$MODE\" = \"wip\" ]; then\n-  git -C \"$toplevel\" diff --stat --cached > \"$root/meta/diff_stat_index.txt\"\n-  git -C \"$toplevel\" diff --name-status --cached > \"$root/meta/name_status_index.txt\"\n-\n-  git -C \"$toplevel\" diff --stat > \"$root/meta/diff_stat_worktree.txt\"\n-  git -C \"$toplevel\" diff --name-status > \"$root/meta/name_status_worktree.txt\"\n-\n-  git -C \"$toplevel\" ls-files --others --exclude-standard > \"$root/meta/untracked_files.txt\"\n-fi\n-\n-# --- CHANGED FILE LIST (stable union) ---\n-{\n-  git -C \"$toplevel\" diff --name-only \"$base..HEAD\"\n-  if [ \"$MODE\" = \"wip\" ]; then\n-    git -C \"$toplevel\" diff --name-only --cached\n-    git -C \"$toplevel\" diff --name-only\n-    git -C \"$toplevel\" ls-files --others --exclude-standard\n-  fi\n-} | sed '/^$/d' | sort -u > \"$root/meta/changed_files.txt\"\n-\n-# --- PATCH ---\n-git -C \"$toplevel\" format-patch --stdout \"$base..HEAD\" > \"$root/patch/series.patch\" || true\n-if [ \"$MODE\" = \"wip\" ]; then\n-  git -C \"$toplevel\" diff --cached > \"$root/patch/wip_index.patch\" || true\n-  git -C \"$toplevel\" diff > \"$root/patch/wip_worktree.patch\" || true\n-fi\n-\n-# --- FILES (latest snapshots of changed files) ---\n-while IFS= read -r f; do\n-  [ -z \"$f\" ] && continue\n-  [ -f \"$toplevel/$f\" ] || continue\n-  mkdir -p \"$root/files/$(dirname \"$f\")\"\n-  cp \"$toplevel/$f\" \"$root/files/$f\"\n-done < \"$root/meta/changed_files.txt\"\n-\n-# --- OPTIONAL EXTRA INCLUDE LIST (.review-bundle.include) ---\n-case \"$INCLUDE_FILE\" in\n-  /*) include_path=\"$INCLUDE_FILE\" ;;\n-  *)  include_path=\"$toplevel/$INCLUDE_FILE\" ;;\n-esac\n-\n-: > \"$root/meta/extra_files.txt\"\n-if [ -f \"$include_path\" ]; then\n-  while IFS= read -r spec; do\n-    # Strip comments + trim whitespace\n-    spec=\"${spec%%#*}\"\n-    spec=\"$(printf \"%s\" \"$spec\" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')\"\n-    [ -z \"$spec\" ] && continue\n-\n-    # safety: disallow absolute and parent traversal\n-    case \"$spec\" in\n-      /*|*..*) echo \"WARN: skip unsafe include spec: $spec\" >> \"$root/meta/warnings.txt\"; continue ;;\n-    esac\n-\n-    # If it looks like a glob, use git pathspec magic :(glob)\n-    if printf \"%s\" \"$spec\" | grep -Eq '[*?\\[]'; then\n-      git -C \"$toplevel\" ls-files -- \":(glob)$spec\" 2>/dev/null >> \"$root/meta/extra_files.txt\" || true\n-    else\n-      # Try tracked path first\n-      git -C \"$toplevel\" ls-files -- \"$spec\" 2>/dev/null >> \"$root/meta/extra_files.txt\" || true\n-      # Also allow untracked explicit file path\n-      if [ -f \"$toplevel/$spec\" ]; then\n-        echo \"$spec\" >> \"$root/meta/extra_files.txt\"\n-      fi\n-    fi\n-  done < \"$include_path\"\n-fi\n-sort -u \"$root/meta/extra_files.txt\" -o \"$root/meta/extra_files.txt\"\n-\n-if [ -s \"$root/meta/extra_files.txt\" ]; then\n-  while IFS= read -r f; do\n-    [ -z \"$f\" ] && continue\n-    [ -f \"$toplevel/$f\" ] || continue\n-    mkdir -p \"$root/files/$(dirname \"$f\")\"\n-    cp \"$toplevel/$f\" \"$root/files/$f\"\n-  done < \"$root/meta/extra_files.txt\"\n-fi\n-\n-# --- EVIDENCE ---\n-if [ -n \"${EVIDENCE_FILE:-}\" ]; then\n-  case \"$EVIDENCE_FILE\" in\n-    /*) ev_path=\"$EVIDENCE_FILE\" ;;\n-    *)  ev_path=\"$toplevel/$EVIDENCE_FILE\" ;;\n-  esac\n-\n-  if [ -f \"$ev_path\" ]; then\n-    cp \"$ev_path\" \"$root/evidence/$(basename \"$ev_path\")\"\n-  else\n-    echo \"WARN: EVIDENCE_FILE specified but not found: $EVIDENCE_FILE\" >> \"$root/meta/warnings.txt\"\n-  fi\n-else\n-  ev=$(\n-    ls -1t \"$toplevel/.local/prverify\"/prverify_*_\"${anchor7}\".md 2>/dev/null | head -n 1 \\\n-    || ls -1t \"$toplevel/.local/prverify\"/prverify_*_\"${head12}\".md 2>/dev/null | head -n 1 \\\n-    || ls -1t \"$toplevel/.local/prverify\"/prverify_*_\"${head7}\".md 2>/dev/null | head -n 1 \\\n-    || true\n-  )\n-\n-  if [ -z \"${ev:-}\" ]; then\n-    ev=\"$(ls -1t \"$toplevel/.local/prverify\"/prverify_*.md 2>/dev/null | head -n 1 || true)\"\n-    if [ -n \"${ev:-}\" ]; then\n-      echo \"WARN: No prverify log found for ANCHOR (${anchor7}) or HEAD (${head12}); included latest: $(basename \"$ev\")\" >> \"$root/meta/warnings.txt\"\n-    fi\n-  fi\n-\n-  if [ -n \"${ev:-}\" ] && [ -f \"$ev\" ]; then\n-    cp \"$ev\" \"$root/evidence/$(basename \"$ev\")\"\n-  else\n-    echo \"WARN: No evidence log found in .local/prverify\" >> \"$root/meta/warnings.txt\"\n-  fi\n-fi\n-\n-# --- INDEX ---\n-{\n-  echo \"# Review Bundle\"\n-  echo\n-  echo \"project: $project\"\n-  echo \"mode:    $MODE\"\n-  echo \"base:    $(cat \"$root/meta/base_sha.txt\")\"\n-  echo \"head:    $(cat \"$root/meta/head_sha.txt\")\"\n-  echo \"branch:  $(cat \"$root/meta/branch.txt\")\"\n-  echo\n-  echo \"## Quick Start\"\n-  echo \"1) meta/changed_files.txt\"\n-  echo \"2) files/ (latest snapshots)\"\n-  echo \"3) patch/series.patch\"\n-  if [ \"$MODE\" = \"wip\" ]; then\n-    echo \"4) patch/wip_index.patch + patch/wip_worktree.patch\"\n-    echo \"5) evidence/ (if present)\"\n-  else\n-    echo \"4) evidence/ (if present)\"\n-  fi\n-  echo\n-  echo \"## Optional\"\n-  echo \"- meta/extra_files.txt (resolved from $INCLUDE_FILE if exists)\"\n-  echo \"- meta/warnings.txt (always present; check if evidence missing)\"\n-} > \"$root/INDEX.md\"\n-\n-# --- PACK ---\n-tar_opts=()\n-if tar --help 2>/dev/null | grep -q -- '--no-xattrs'; then tar_opts+=(--no-xattrs); fi\n-if tar --help 2>/dev/null | grep -q -- '--no-mac-metadata'; then tar_opts+=(--no-mac-metadata); fi\n-\n-COPYFILE_DISABLE=1 tar ${tar_opts[@]+\"${tar_opts[@]}\"} -czf \"$out\" -C \"$tmp\" review\n-\n-ls -lh \"$out\"\n-echo \"OK: $out\"\n+echo \"Shimming to reviewbundle (Go)...\"\n+exec go run ./cmd/reviewbundle create","path":"ops/ci/review_bundle.sh","commit_id":"41a44446285de74eff61cdd07d2a3837665be82a","original_commit_id":"4039a3ec26070e218fdfb1f2a77ba461c47272ee","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The shim script uses \"MODE=wip\" as default, but does not pass the MODE environment variable to the Go implementation. The Go create command hardcodes mode as \"wip\" in main.go. This means the legacy MODE=clean usage will be ignored. Consider reading the MODE environment variable and passing it as a flag to the Go command to maintain backward compatibility.\n```suggestion\nexec go run ./cmd/reviewbundle create --mode=\"${MODE}\"\n```","created_at":"2026-02-16T14:15:29Z","updated_at":"2026-02-16T14:15:33Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644451","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644451"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644451"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644451/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":14,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":268,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644480","pull_request_review_id":3808873517,"id":2812644480,"node_id":"PRRC_kwDOQkbgjc6npYyA","diff_hunk":"@@ -1,261 +1,14 @@\n #!/usr/bin/env bash\n set -euo pipefail\n \n-# Review bundle generator (repo-agnostic / deterministic-ish / human-friendly)\n-#\n-# Modes:\n-#   MODE=clean (default): requires clean working tree; bundles committed range base..HEAD\n-#   MODE=wip             : allows dirty tree; also bundles staged/unstaged/untracked changes\n-#\n-# Output:\n-#   default OUT_DIR: .local/review-bundles (inside repo toplevel)\n-#\n-# Optional extra include list:\n-#   INCLUDE_FILE (default): .review-bundle.include\n-#   - one pathspec per line (supports simple globs like docs/runbook/*.md)\n-#   - blank lines and comments (# ...) are ignored\n-#\n-# Evidence:\n-#   - If EVIDENCE_FILE is set, it is included (absolute or relative to repo root)\n-#   - Otherwise auto-detect .local/prverify:\n-#       1) Prefer logs matching HEAD (12 or 7 short SHA)\n-#       2) Fallback to latest prverify_*.md with a warning trail\n-#\n-# Usage (from repo root):\n-#   bash ops/review_bundle.sh\n-#   MODE=wip bash ops/review_bundle.sh\n-#\n-# Optional:\n-#   REPO=../some-repo BASE_REF=origin/main OUT_DIR=.local/review-bundles MODE=wip bash ops/review_bundle.sh\n+# Shim for the new Go implementation (S11-03)\n+# Translates legacy environment variables to the new Go tool.\n \n-repo=\"${REPO:-.}\"\n-BASE_REF=\"${BASE_REF:-origin/main}\"\n-MODE=\"${MODE:-clean}\"\n+MODE=\"${MODE:-wip}\"\n OUT_DIR=\"${OUT_DIR:-.local/review-bundles}\"\n-INCLUDE_FILE=\"${INCLUDE_FILE:-.review-bundle.include}\"\n-ts=\"$(date +'%Y%m%d_%H%M%S')\"\n \n-cleanup() {\n-  if [ -n \"${tmp:-}\" ] && [ -d \"${tmp:-}\" ]; then\n-    rm -rf \"$tmp\"\n-  fi\n-}\n-trap cleanup EXIT\n+# Ensure we use Go 1.24\n+export GOTOOLCHAIN=local","path":"ops/ci/review_bundle.sh","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"4039a3ec26070e218fdfb1f2a77ba461c47272ee","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The GOTOOLCHAIN=local setting may cause issues if the system doesn't have Go 1.24 installed (which doesn't exist). This setting prevents automatic Go toolchain downloads. Since Go 1.24.11 doesn't exist, this will likely fail. Consider either removing this line or using GOTOOLCHAIN=auto with a valid Go version.\n```suggestion\n# Use the Go toolchain specified by the module (allow automatic downloads)\nexport GOTOOLCHAIN=auto\n```","created_at":"2026-02-16T14:15:30Z","updated_at":"2026-02-16T14:15:33Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644480","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644480"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644480"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644480/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":10,"original_start_line":10,"start_side":"RIGHT","line":11,"original_line":11,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":48,"position":48,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644496","pull_request_review_id":3808873517,"id":2812644496,"node_id":"PRRC_kwDOQkbgjc6npYyQ","diff_hunk":"@@ -0,0 +1,290 @@\n+package main\n+\n+import (\n+\t\"archive/tar\"\n+\t\"compress/gzip\"\n+\t\"crypto/sha256\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+func CreateBundleUI(mode, outDir string, stdout, stderr io.Writer) error {\n+\tepoch, err := ComputeEpochSec()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\theadSHA, err := getGitHeadSHA()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfmt.Fprintf(stdout, \"Creating bundle (mode=%s, epoch=%d, head=%s)\\n\", mode, epoch, headSHA[:12])\n+\n+\t// C4: Pre-checks\n+\tisDirty, err := isGitDirty()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif mode == ModeStrict {\n+\t\tif isDirty {\n+\t\t\treturn NewVError(E_CONTRACT, \"git\", \"repository is dirty (prohibited in strict mode)\")\n+\t\t}\n+\t\t// Evidence check will come in C5/C6\n+\t} else if mode == ModeWIP {\n+\t\tif isDirty {\n+\t\t\tfmt.Fprintln(stderr, \"WARN: repository is dirty\")\n+\t\t}\n+\t}\n+\n+\t// C4: contract.json generation\n+\tcontract := &Contract{\n+\t\tContractVersion: \"1.1\",\n+\t\tMode:            mode,\n+\t\tRepo:            \"veil-rs\", // Canonical","path":"cmd/reviewbundle/create.go","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"4039a3ec26070e218fdfb1f2a77ba461c47272ee","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The repository name is hardcoded as \"veil-rs\" instead of being dynamically determined from the git repository. This breaks the \"repo-agnostic\" design mentioned in the PR description and the original bash script comment. Consider using git config to get the repository URL or name, or accept it as a parameter.","created_at":"2026-02-16T14:15:30Z","updated_at":"2026-02-16T14:15:33Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644496","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644496"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644496"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644496/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":53,"original_line":53,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":53,"position":53,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644521","pull_request_review_id":3808873517,"id":2812644521,"node_id":"PRRC_kwDOQkbgjc6npYyp","diff_hunk":"@@ -0,0 +1,475 @@\n+package main\n+\n+import (\n+\t\"archive/tar\"\n+\t\"compress/gzip\"\n+\t\"crypto/sha256\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"path\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+type Contract struct {\n+\tContractVersion string   `json:\"contract_version\"`\n+\tMode            string   `json:\"mode\"`\n+\tRepo            string   `json:\"repo\"`\n+\tEpochSec        int64    `json:\"epoch_sec\"`\n+\tBaseRef         string   `json:\"base_ref\"`\n+\tHeadSHA         string   `json:\"head_sha\"`\n+\tWarningsCount   int      `json:\"warnings_count\"`\n+\tEvidence        Evidence `json:\"evidence\"`\n+\tTool            Tool     `json:\"tool\"`\n+}\n+\n+type Evidence struct {\n+\tRequired    bool   `json:\"required\"`\n+\tPresent     bool   `json:\"present\"`\n+\tBoundToHead bool   `json:\"bound_to_head\"`\n+\tPathPrefix  string `json:\"path_prefix\"`\n+}\n+\n+type Tool struct {\n+\tName    string `json:\"name\"`\n+\tVersion string `json:\"version\"`\n+\tBuild   string `json:\"build,omitempty\"`\n+}\n+\n+type VerifyReport struct {\n+\tContract *Contract\n+\n+\t// computed\n+\tComputedSHA256 map[string][32]byte\n+\n+\t// extracted raw files (needed for seal/checks)\n+\tSHA256SUMS     []byte\n+\tSHA256SUMSSeal []byte\n+\tWarningsTxt    []byte\n+\tEvidenceFiles  [][]byte\n+\n+\t// required layout presence\n+\tHasIndex          bool\n+\tHasContractJSON   bool\n+\tHasSHA256SUMS     bool\n+\tHasSHA256SUMSSeal bool\n+\tHasSeriesPatch    bool\n+\n+\t// evidence scan result\n+\tEvidencePresent     bool\n+\tEvidenceBoundToHead bool\n+\n+\t// captured gzip header (for post-check)\n+\tGzipModTime time.Time\n+\tGzipName    string\n+\tGzipComment string\n+\tGzipExtra   []byte\n+\tGzipOS      byte\n+}\n+\n+func VerifyBundlePath(path string) (*VerifyReport, error) {\n+\tf, err := os.Open(path)\n+\tif err != nil {\n+\t\treturn nil, WrapVError(E_PATH, path, err)\n+\t}\n+\tdefer f.Close()\n+\treturn VerifyBundle(f)\n+}\n+\n+func VerifyBundle(r io.Reader) (*VerifyReport, error) {\n+\trep, err := verifyReportFromStream(r)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif err := verifyPostConditions(rep); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn rep, nil\n+}\n+\n+func verifyReportFromStream(r io.Reader) (*VerifyReport, error) {\n+\trep := &VerifyReport{\n+\t\tComputedSHA256: make(map[string][32]byte),\n+\t}\n+\n+\tgz, err := gzip.NewReader(r)\n+\tif err != nil {\n+\t\treturn nil, WrapVError(E_GZIP, \"stream\", err)\n+\t}\n+\tdefer gz.Close()\n+\n+\t// Capture gzip header\n+\trep.GzipModTime = gz.Header.ModTime\n+\trep.GzipName = gz.Header.Name\n+\trep.GzipComment = gz.Header.Comment\n+\trep.GzipExtra = gz.Header.Extra\n+\trep.GzipOS = gz.Header.OS\n+\n+\ttr := tar.NewReader(gz)\n+\tvar prevNameCanon string\n+\tvar seenFirst bool\n+\tvar seenSec int64\n+\n+\tfor {\n+\t\thdr, err := tr.Next()\n+\t\tif err == io.EOF {\n+\t\t\tbreak\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn nil, WrapVError(E_GZIP, \"tar stream corrupted\", err)\n+\t\t}\n+\n+\t\tname := hdr.Name\n+\n+\t\tif err := validateTarOrder(name, prevNameCanon, seenFirst); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tprevNameCanon = name\n+\t\tseenFirst = true\n+\n+\t\tif err := validateTarPath(name, hdr.Typeflag); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarType(name, hdr.Typeflag); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarIdentity(name, hdr); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarTime(name, hdr, &seenSec); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarPAX(name, hdr); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\tupdateLayoutPresence(name, hdr, rep)\n+\n+\t\tif err := processEntryContent(tr, hdr, rep); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\treturn rep, nil\n+}\n+\n+func validateTarOrder(name, prev string, seenFirst bool) error {\n+\tif seenFirst && name < prev {\n+\t\treturn NewVError(E_ORDER, name, fmt.Sprintf(\"is not sorted (prev: %s)\", prev))\n+\t}\n+\treturn nil\n+}\n+\n+func validateTarPath(name string, typeFlag byte) error {\n+\tif strings.HasPrefix(name, \"/\") {\n+\t\treturn NewVError(E_PATH, name, \"absolute path forbidden\")\n+\t}\n+\tif strings.Contains(name, \"\\x00\") {\n+\t\treturn NewVError(E_PATH, name, \"contains NUL char\")\n+\t}\n+\tif strings.Contains(name, \"\\\\\") {\n+\t\treturn NewVError(E_PATH, name, \"contains backslash\")\n+\t}\n+\tclean := path.Clean(name)\n+\tif clean == \"..\" || strings.HasPrefix(clean, \"../\") {\n+\t\treturn NewVError(E_PATH, name, \"parent traversal prohibited\")\n+\t}\n+\n+\t// Normalize check\n+\tnormalized := clean\n+\tif typeFlag == tar.TypeDir && !strings.HasSuffix(normalized, \"/\") {\n+\t\tif name != clean && name != clean+\"/\" {\n+\t\t\treturn NewVError(E_PATH, name, \"path not normalized\")\n+\t\t}\n+\t} else {\n+\t\tif name != clean {\n+\t\t\treturn NewVError(E_PATH, name, \"path not normalized\")\n+\t\t}\n+\t}","path":"cmd/reviewbundle/verify.go","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"4039a3ec26070e218fdfb1f2a77ba461c47272ee","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"There's a logic error in the path normalization check. For directories, the condition checks if name doesn't equal either clean or clean+\"/\", but then only returns an error if neither matches. This is confusing and may not work as intended. The logic should be simplified: for directories, name should equal either clean or clean+\"/\". For files, name should equal clean.","created_at":"2026-02-16T14:15:30Z","updated_at":"2026-02-16T14:15:30Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644521","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644521"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2812644521"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2812644521/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":181,"original_start_line":179,"start_side":"RIGHT","line":191,"original_line":189,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":189,"position":191,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584607","pull_request_review_id":3811169344,"id":2814584607,"node_id":"PRRC_kwDOQkbgjc6nwycf","diff_hunk":"@@ -0,0 +1,310 @@\n+package main\n+\n+import (\n+\t\"archive/tar\"\n+\t\"compress/gzip\"\n+\t\"crypto/sha256\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+func CreateBundleUI(mode, outDir, repoDir string, stdout, stderr io.Writer) error {\n+\tepoch, err := ComputeEpochSec(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\theadSHA, err := getGitHeadSHA(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfmt.Fprintf(stdout, \"Creating bundle (mode=%s, epoch=%d, head=%s)\\n\", mode, epoch, headSHA[:12])\n+\n+\t// C4: Pre-checks\n+\tisDirty, err := isGitDirty(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif mode == ModeStrict {\n+\t\tif isDirty {\n+\t\t\treturn NewVError(E_CONTRACT, \"git\", \"repository is dirty (prohibited in strict mode)\")\n+\t\t}\n+\t\t// Evidence check will come in C5/C6\n+\t} else if mode == ModeWIP {\n+\t\tif isDirty {\n+\t\t\tfmt.Fprintln(stderr, \"WARN: repository is dirty\")\n+\t\t}\n+\t}\n+\n+\t// C4: contract.json generation\n+\tcontract := &Contract{\n+\t\tContractVersion: \"1.1\",\n+\t\tMode:            mode,\n+\t\tRepo:            \"veil-rs\", // Canonical\n+\t\tEpochSec:        epoch,\n+\t\tBaseRef:         \"main\", // Canonical entry\n+\t\tHeadSHA:         headSHA,\n+\t\tWarningsCount:   0,\n+\t\tEvidence: Evidence{\n+\t\t\tRequired:    mode == ModeStrict,\n+\t\t\tPresent:     false,\n+\t\t\tBoundToHead: false,\n+\t\t\tPathPrefix:  DirEvidence,\n+\t\t},\n+\t\tTool: Tool{\n+\t\t\tName:    \"reviewbundle\",\n+\t\t\tVersion: \"1.0.0\",\n+\t\t},\n+\t}\n+\n+\tif isDirty {\n+\t\tcontract.WarningsCount++\n+\t}","path":"cmd/reviewbundle/create.go","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"861ea41442259d138397665f9e13df7b80d7e3be","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"In WIP mode, `WarningsCount` is incremented when the repo is dirty, but the bundle generator never writes `review/meta/warnings.txt`. The verifier later requires `warnings.txt` when `warnings_count > 0`, so creating a bundle from a dirty tree will fail the self-audit and prevent the main WIP use-case.\n\nWrite `review/meta/warnings.txt` into the bundle (even if empty), and when `WarningsCount > 0` ensure the file content explains the warning(s) and matches the count.","created_at":"2026-02-17T01:32:00Z","updated_at":"2026-02-17T01:32:04Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814584607","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584607"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814584607"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584607/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":70,"original_start_line":70,"start_side":"RIGHT","line":72,"original_line":72,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":72,"position":72,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584614","pull_request_review_id":3811169344,"id":2814584614,"node_id":"PRRC_kwDOQkbgjc6nwycm","diff_hunk":"@@ -0,0 +1,310 @@\n+package main\n+\n+import (\n+\t\"archive/tar\"\n+\t\"compress/gzip\"\n+\t\"crypto/sha256\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+func CreateBundleUI(mode, outDir, repoDir string, stdout, stderr io.Writer) error {\n+\tepoch, err := ComputeEpochSec(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\theadSHA, err := getGitHeadSHA(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfmt.Fprintf(stdout, \"Creating bundle (mode=%s, epoch=%d, head=%s)\\n\", mode, epoch, headSHA[:12])\n+\n+\t// C4: Pre-checks\n+\tisDirty, err := isGitDirty(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif mode == ModeStrict {\n+\t\tif isDirty {\n+\t\t\treturn NewVError(E_CONTRACT, \"git\", \"repository is dirty (prohibited in strict mode)\")\n+\t\t}\n+\t\t// Evidence check will come in C5/C6\n+\t} else if mode == ModeWIP {\n+\t\tif isDirty {\n+\t\t\tfmt.Fprintln(stderr, \"WARN: repository is dirty\")\n+\t\t}\n+\t}\n+\n+\t// C4: contract.json generation\n+\tcontract := &Contract{\n+\t\tContractVersion: \"1.1\",\n+\t\tMode:            mode,\n+\t\tRepo:            \"veil-rs\", // Canonical\n+\t\tEpochSec:        epoch,\n+\t\tBaseRef:         \"main\", // Canonical entry\n+\t\tHeadSHA:         headSHA,\n+\t\tWarningsCount:   0,\n+\t\tEvidence: Evidence{\n+\t\t\tRequired:    mode == ModeStrict,\n+\t\t\tPresent:     false,\n+\t\t\tBoundToHead: false,\n+\t\t\tPathPrefix:  DirEvidence,\n+\t\t},\n+\t\tTool: Tool{\n+\t\t\tName:    \"reviewbundle\",\n+\t\t\tVersion: \"1.0.0\",\n+\t\t},\n+\t}\n+\n+\tif isDirty {\n+\t\tcontract.WarningsCount++\n+\t}\n+\n+\t// C5/C6: Actual bundle generation\n+\tpath, err := CreateBundle(contract, outDir, repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfmt.Fprintf(stdout, \"Bundle created: %s\\n\", path)\n+\treturn nil\n+}\n+\n+func CreateBundle(c *Contract, outDir, repoDir string) (string, error) {\n+\tif err := os.MkdirAll(outDir, 0755); err != nil {\n+\t\treturn \"\", WrapVError(E_PATH, outDir, err)\n+\t}\n+\n+\tts := time.Unix(c.EpochSec, 0).UTC().Format(\"20060102_150405\")\n+\tname := fmt.Sprintf(\"veil-rs_review_%s_%s_%s.tar.gz\", c.Mode, ts, c.HeadSHA[:12])\n+\toutPath := filepath.Join(outDir, name)\n+\n+\ttmpPath := outPath + \".tmp\"\n+\tf, err := os.Create(tmpPath)\n+\tif err != nil {\n+\t\treturn \"\", WrapVError(E_PATH, tmpPath, err)\n+\t}\n+\tdefer os.Remove(tmpPath)\n+\tdefer f.Close()\n+\n+\tgw := gzip.NewWriter(f)\n+\tgw.Header.ModTime = time.Unix(c.EpochSec, 0)\n+\tgw.Header.OS = 255\n+\tdefer gw.Close()\n+\n+\ttw := tar.NewWriter(gw)\n+\tdefer tw.Close()\n+\n+\t// 1. Gather files\n+\tfiles := make(map[string][]byte)\n+\n+\t// INDEX.md\n+\tfiles[PathIndex] = []byte(fmt.Sprintf(\"# Review Bundle\\n\\nMode: %s\\nEpoch: %d\\nHead: %s\\n\", c.Mode, c.EpochSec, c.HeadSHA))\n+\n+\t// patch/series.patch\n+\tpatch, err := getGitPatch(c.BaseRef, c.HeadSHA, repoDir)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tfiles[PathSeriesPatch] = patch\n+","path":"cmd/reviewbundle/create.go","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"861ea41442259d138397665f9e13df7b80d7e3be","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The bundle currently omits `review/files/**` snapshots entirely; it only includes INDEX, contract, patch, checksums, and evidence. This conflicts with the contract doc (layout lists `review/files/**`) and also reduces reviewer utility compared to the legacy script.\n\nEither add the `review/files/**` snapshot generation (ideally from git blobs for strict determinism), or adjust the contract/layout to make file snapshots optional and update verification accordingly.","created_at":"2026-02-17T01:32:00Z","updated_at":"2026-02-17T01:32:04Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814584614","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584614"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814584614"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584614/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":109,"original_start_line":109,"start_side":"RIGHT","line":121,"original_line":121,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":121,"position":121,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584621","pull_request_review_id":3811169344,"id":2814584621,"node_id":"PRRC_kwDOQkbgjc6nwyct","diff_hunk":"@@ -0,0 +1,310 @@\n+package main\n+\n+import (\n+\t\"archive/tar\"\n+\t\"compress/gzip\"\n+\t\"crypto/sha256\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+func CreateBundleUI(mode, outDir, repoDir string, stdout, stderr io.Writer) error {\n+\tepoch, err := ComputeEpochSec(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\theadSHA, err := getGitHeadSHA(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfmt.Fprintf(stdout, \"Creating bundle (mode=%s, epoch=%d, head=%s)\\n\", mode, epoch, headSHA[:12])\n+\n+\t// C4: Pre-checks\n+\tisDirty, err := isGitDirty(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif mode == ModeStrict {\n+\t\tif isDirty {\n+\t\t\treturn NewVError(E_CONTRACT, \"git\", \"repository is dirty (prohibited in strict mode)\")\n+\t\t}\n+\t\t// Evidence check will come in C5/C6\n+\t} else if mode == ModeWIP {\n+\t\tif isDirty {\n+\t\t\tfmt.Fprintln(stderr, \"WARN: repository is dirty\")\n+\t\t}\n+\t}\n+\n+\t// C4: contract.json generation\n+\tcontract := &Contract{\n+\t\tContractVersion: \"1.1\",\n+\t\tMode:            mode,\n+\t\tRepo:            \"veil-rs\", // Canonical\n+\t\tEpochSec:        epoch,\n+\t\tBaseRef:         \"main\", // Canonical entry\n+\t\tHeadSHA:         headSHA,\n+\t\tWarningsCount:   0,\n+\t\tEvidence: Evidence{\n+\t\t\tRequired:    mode == ModeStrict,\n+\t\t\tPresent:     false,\n+\t\t\tBoundToHead: false,\n+\t\t\tPathPrefix:  DirEvidence,\n+\t\t},\n+\t\tTool: Tool{\n+\t\t\tName:    \"reviewbundle\",\n+\t\t\tVersion: \"1.0.0\",\n+\t\t},\n+\t}\n+\n+\tif isDirty {\n+\t\tcontract.WarningsCount++\n+\t}\n+\n+\t// C5/C6: Actual bundle generation\n+\tpath, err := CreateBundle(contract, outDir, repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfmt.Fprintf(stdout, \"Bundle created: %s\\n\", path)\n+\treturn nil\n+}\n+\n+func CreateBundle(c *Contract, outDir, repoDir string) (string, error) {\n+\tif err := os.MkdirAll(outDir, 0755); err != nil {\n+\t\treturn \"\", WrapVError(E_PATH, outDir, err)\n+\t}\n+\n+\tts := time.Unix(c.EpochSec, 0).UTC().Format(\"20060102_150405\")\n+\tname := fmt.Sprintf(\"veil-rs_review_%s_%s_%s.tar.gz\", c.Mode, ts, c.HeadSHA[:12])\n+\toutPath := filepath.Join(outDir, name)\n+\n+\ttmpPath := outPath + \".tmp\"\n+\tf, err := os.Create(tmpPath)\n+\tif err != nil {\n+\t\treturn \"\", WrapVError(E_PATH, tmpPath, err)\n+\t}\n+\tdefer os.Remove(tmpPath)\n+\tdefer f.Close()\n+\n+\tgw := gzip.NewWriter(f)\n+\tgw.Header.ModTime = time.Unix(c.EpochSec, 0)\n+\tgw.Header.OS = 255\n+\tdefer gw.Close()\n+\n+\ttw := tar.NewWriter(gw)\n+\tdefer tw.Close()\n+\n+\t// 1. Gather files\n+\tfiles := make(map[string][]byte)\n+\n+\t// INDEX.md\n+\tfiles[PathIndex] = []byte(fmt.Sprintf(\"# Review Bundle\\n\\nMode: %s\\nEpoch: %d\\nHead: %s\\n\", c.Mode, c.EpochSec, c.HeadSHA))\n+\n+\t// patch/series.patch\n+\tpatch, err := getGitPatch(c.BaseRef, c.HeadSHA, repoDir)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tfiles[PathSeriesPatch] = patch\n+\n+\t// Evidence (Phase 7.5/8/9)\n+\tbound, evFiles, err := collectEvidence(c.HeadSHA, repoDir)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tif len(evFiles) > 0 {\n+\t\tc.Evidence.Present = true\n+\t\tc.Evidence.BoundToHead = bound\n+\t\tfor name, content := range evFiles {\n+\t\t\tfiles[name] = content\n+\t\t}\n+\t}\n+\n+\t// meta/contract.json (update with evidence findings)\n+\tcj, _ := json.MarshalIndent(c, \"\", \"  \")\n+\tfiles[PathContract] = cj\n+\n+\t// 2. Generate SHA256SUMS (C6)\n+\tvar manifestKeys []string\n+\tfor k := range files {\n+\t\tmanifestKeys = append(manifestKeys, k)\n+\t}\n+\tsort.Strings(manifestKeys)\n+\n+\tvar sumsBuilder strings.Builder\n+\tfor _, k := range manifestKeys {\n+\t\th := sha256.Sum256(files[k])\n+\t\tfmt.Fprintf(&sumsBuilder, \"%x  %s\\n\", h, k)\n+\t}\n+\tsums := []byte(sumsBuilder.String())\n+\tfiles[PathSHA256SUMS] = sums\n+\n+\t// seal\n+\tseal := sha256.Sum256(sums)\n+\tfiles[PathSHA256SUMSSeal] = []byte(fmt.Sprintf(\"%x  %s\\n\", seal, PathSHA256SUMS))\n+\n+\t// 3. Sort and write (C5)\n+\tvar keys []string\n+\tfor k := range files {\n+\t\tkeys = append(keys, k)\n+\t}\n+\tsort.Strings(keys)\n+\n+\tfor _, k := range keys {\n+\t\tcontent := files[k]\n+\t\thdr := &tar.Header{\n+\t\t\tName:     k,\n+\t\t\tSize:     int64(len(content)),\n+\t\t\tMode:     0644,\n+\t\t\tModTime:  time.Unix(c.EpochSec, 0),\n+\t\t\tTypeflag: tar.TypeReg,\n+\t\t\tUid:      0,\n+\t\t\tGid:      0,\n+\t\t\tUname:    \"\",\n+\t\t\tGname:    \"\",\n+\t\t\tFormat:   tar.FormatPAX,\n+\t\t\t// Phase 4.2/7.3: Explicitly zero extra times to avoid PAX mtime/atime/ctime\n+\t\t\tAccessTime: time.Time{},\n+\t\t\tChangeTime: time.Time{},\n+\t\t\tPAXRecords: nil,\n+\t\t}\n+\t\tif err := tw.WriteHeader(hdr); err != nil {\n+\t\t\treturn \"\", WrapVError(E_GZIP, k, err)\n+\t\t}\n+\t\tif _, err := tw.Write(content); err != nil {\n+\t\t\treturn \"\", WrapVError(E_GZIP, k, err)\n+\t\t}\n+\t}\n+\n+\ttw.Close()\n+\tgw.Close()\n+\tf.Close()\n+\n+\tif err := os.Rename(tmpPath, outPath); err != nil {\n+\t\treturn \"\", WrapVError(E_PATH, outPath, err)\n+\t}\n+\n+\t// 4. Self-Audit (C6)\n+\t_, err = VerifyBundlePath(outPath)\n+\tif err != nil {\n+\t\t// If verification fails, we keep the broken bundle for inspection but return error\n+\t\treturn outPath, fmt.Errorf(\"self-audit failed for %s: %w\", outPath, err)\n+\t}\n+\n+\treturn outPath, nil\n+}\n+\n+func getGitPatch(base, head, repoDir string) ([]byte, error) {\n+\tcmd := exec.Command(\"git\", \"format-patch\", \"--stdout\", base+\"..\"+head)\n+\tif repoDir != \"\" {\n+\t\tcmd.Dir = repoDir\n+\t}\n+\tout, err := cmd.Output()\n+\tif err != nil {\n+\t\treturn nil, WrapVError(E_CONTRACT, \"git format-patch\", err)\n+\t}\n+\treturn out, nil\n+}\n+\n+func ComputeEpochSec(repoDir string) (int64, error) {\n+\tif s := os.Getenv(\"SOURCE_DATE_EPOCH\"); s != \"\" {\n+\t\tsec, err := strconv.ParseInt(s, 10, 64)\n+\t\tif err == nil {\n+\t\t\treturn sec, nil\n+\t\t}","path":"cmd/reviewbundle/create.go","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"861ea41442259d138397665f9e13df7b80d7e3be","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"`ComputeEpochSec` silently ignores an invalid `SOURCE_DATE_EPOCH` value and falls back to `git show`. Per the determinism contract, if the env var is set it should be the epoch source; falling back can make builds unexpectedly non-reproducible.\n\nReturn an error when `SOURCE_DATE_EPOCH` is set but unparsable (or at least emit a warning and fail in strict mode).\n```suggestion\n\t\tif err != nil {\n\t\t\treturn 0, WrapVError(E_CONTRACT, \"invalid SOURCE_DATE_EPOCH\", err)\n\t\t}\n\t\treturn sec, nil\n```","created_at":"2026-02-17T01:32:01Z","updated_at":"2026-02-17T01:32:04Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814584621","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584621"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814584621"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584621/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":224,"original_start_line":224,"start_side":"RIGHT","line":226,"original_line":226,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":226,"position":226,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584629","pull_request_review_id":3811169344,"id":2814584629,"node_id":"PRRC_kwDOQkbgjc6nwyc1","diff_hunk":"@@ -0,0 +1,310 @@\n+package main\n+\n+import (\n+\t\"archive/tar\"\n+\t\"compress/gzip\"\n+\t\"crypto/sha256\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+func CreateBundleUI(mode, outDir, repoDir string, stdout, stderr io.Writer) error {\n+\tepoch, err := ComputeEpochSec(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\theadSHA, err := getGitHeadSHA(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfmt.Fprintf(stdout, \"Creating bundle (mode=%s, epoch=%d, head=%s)\\n\", mode, epoch, headSHA[:12])\n+\n+\t// C4: Pre-checks\n+\tisDirty, err := isGitDirty(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif mode == ModeStrict {\n+\t\tif isDirty {\n+\t\t\treturn NewVError(E_CONTRACT, \"git\", \"repository is dirty (prohibited in strict mode)\")\n+\t\t}\n+\t\t// Evidence check will come in C5/C6\n+\t} else if mode == ModeWIP {\n+\t\tif isDirty {\n+\t\t\tfmt.Fprintln(stderr, \"WARN: repository is dirty\")\n+\t\t}\n+\t}\n+\n+\t// C4: contract.json generation\n+\tcontract := &Contract{\n+\t\tContractVersion: \"1.1\",\n+\t\tMode:            mode,\n+\t\tRepo:            \"veil-rs\", // Canonical\n+\t\tEpochSec:        epoch,\n+\t\tBaseRef:         \"main\", // Canonical entry\n+\t\tHeadSHA:         headSHA,\n+\t\tWarningsCount:   0,\n+\t\tEvidence: Evidence{\n+\t\t\tRequired:    mode == ModeStrict,\n+\t\t\tPresent:     false,\n+\t\t\tBoundToHead: false,\n+\t\t\tPathPrefix:  DirEvidence,\n+\t\t},\n+\t\tTool: Tool{\n+\t\t\tName:    \"reviewbundle\",\n+\t\t\tVersion: \"1.0.0\",\n+\t\t},\n+\t}\n+\n+\tif isDirty {\n+\t\tcontract.WarningsCount++\n+\t}\n+\n+\t// C5/C6: Actual bundle generation\n+\tpath, err := CreateBundle(contract, outDir, repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfmt.Fprintf(stdout, \"Bundle created: %s\\n\", path)\n+\treturn nil\n+}\n+\n+func CreateBundle(c *Contract, outDir, repoDir string) (string, error) {\n+\tif err := os.MkdirAll(outDir, 0755); err != nil {\n+\t\treturn \"\", WrapVError(E_PATH, outDir, err)\n+\t}\n+\n+\tts := time.Unix(c.EpochSec, 0).UTC().Format(\"20060102_150405\")\n+\tname := fmt.Sprintf(\"veil-rs_review_%s_%s_%s.tar.gz\", c.Mode, ts, c.HeadSHA[:12])\n+\toutPath := filepath.Join(outDir, name)\n+\n+\ttmpPath := outPath + \".tmp\"\n+\tf, err := os.Create(tmpPath)\n+\tif err != nil {\n+\t\treturn \"\", WrapVError(E_PATH, tmpPath, err)\n+\t}\n+\tdefer os.Remove(tmpPath)\n+\tdefer f.Close()\n+\n+\tgw := gzip.NewWriter(f)\n+\tgw.Header.ModTime = time.Unix(c.EpochSec, 0)\n+\tgw.Header.OS = 255\n+\tdefer gw.Close()\n+\n+\ttw := tar.NewWriter(gw)\n+\tdefer tw.Close()\n+\n+\t// 1. Gather files\n+\tfiles := make(map[string][]byte)\n+\n+\t// INDEX.md\n+\tfiles[PathIndex] = []byte(fmt.Sprintf(\"# Review Bundle\\n\\nMode: %s\\nEpoch: %d\\nHead: %s\\n\", c.Mode, c.EpochSec, c.HeadSHA))\n+\n+\t// patch/series.patch\n+\tpatch, err := getGitPatch(c.BaseRef, c.HeadSHA, repoDir)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tfiles[PathSeriesPatch] = patch\n+\n+\t// Evidence (Phase 7.5/8/9)\n+\tbound, evFiles, err := collectEvidence(c.HeadSHA, repoDir)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tif len(evFiles) > 0 {\n+\t\tc.Evidence.Present = true\n+\t\tc.Evidence.BoundToHead = bound\n+\t\tfor name, content := range evFiles {\n+\t\t\tfiles[name] = content\n+\t\t}\n+\t}\n+\n+\t// meta/contract.json (update with evidence findings)\n+\tcj, _ := json.MarshalIndent(c, \"\", \"  \")\n+\tfiles[PathContract] = cj\n+\n+\t// 2. Generate SHA256SUMS (C6)\n+\tvar manifestKeys []string\n+\tfor k := range files {\n+\t\tmanifestKeys = append(manifestKeys, k)\n+\t}\n+\tsort.Strings(manifestKeys)\n+\n+\tvar sumsBuilder strings.Builder\n+\tfor _, k := range manifestKeys {\n+\t\th := sha256.Sum256(files[k])\n+\t\tfmt.Fprintf(&sumsBuilder, \"%x  %s\\n\", h, k)\n+\t}\n+\tsums := []byte(sumsBuilder.String())\n+\tfiles[PathSHA256SUMS] = sums\n+\n+\t// seal\n+\tseal := sha256.Sum256(sums)\n+\tfiles[PathSHA256SUMSSeal] = []byte(fmt.Sprintf(\"%x  %s\\n\", seal, PathSHA256SUMS))\n+\n+\t// 3. Sort and write (C5)\n+\tvar keys []string\n+\tfor k := range files {\n+\t\tkeys = append(keys, k)\n+\t}\n+\tsort.Strings(keys)\n+\n+\tfor _, k := range keys {\n+\t\tcontent := files[k]\n+\t\thdr := &tar.Header{\n+\t\t\tName:     k,\n+\t\t\tSize:     int64(len(content)),\n+\t\t\tMode:     0644,\n+\t\t\tModTime:  time.Unix(c.EpochSec, 0),\n+\t\t\tTypeflag: tar.TypeReg,\n+\t\t\tUid:      0,\n+\t\t\tGid:      0,\n+\t\t\tUname:    \"\",\n+\t\t\tGname:    \"\",\n+\t\t\tFormat:   tar.FormatPAX,\n+\t\t\t// Phase 4.2/7.3: Explicitly zero extra times to avoid PAX mtime/atime/ctime\n+\t\t\tAccessTime: time.Time{},\n+\t\t\tChangeTime: time.Time{},\n+\t\t\tPAXRecords: nil,\n+\t\t}\n+\t\tif err := tw.WriteHeader(hdr); err != nil {\n+\t\t\treturn \"\", WrapVError(E_GZIP, k, err)\n+\t\t}\n+\t\tif _, err := tw.Write(content); err != nil {\n+\t\t\treturn \"\", WrapVError(E_GZIP, k, err)\n+\t\t}\n+\t}\n+\n+\ttw.Close()\n+\tgw.Close()\n+\tf.Close()","path":"cmd/reviewbundle/create.go","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"861ea41442259d138397665f9e13df7b80d7e3be","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"`tw.Close()`, `gw.Close()`, and `f.Close()` are called explicitly here while also being deferred earlier, and the explicit close errors are ignored. Since tar/gzip `Close()` is where trailers are written, ignoring errors can produce a corrupted archive that only fails later.\n\nPrefer a single close path that checks and returns `Close()` errors (and remove the redundant defers or explicit calls).\n```suggestion\n\tif err := tw.Close(); err != nil {\n\t\treturn \"\", WrapVError(E_GZIP, tmpPath, err)\n\t}\n\tif err := gw.Close(); err != nil {\n\t\treturn \"\", WrapVError(E_GZIP, tmpPath, err)\n\t}\n\tif err := f.Close(); err != nil {\n\t\treturn \"\", WrapVError(E_PATH, tmpPath, err)\n\t}\n```","created_at":"2026-02-17T01:32:01Z","updated_at":"2026-02-17T01:32:04Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814584629","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584629"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814584629"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584629/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":191,"original_start_line":191,"start_side":"RIGHT","line":193,"original_line":193,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":193,"position":193,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584635","pull_request_review_id":3811169344,"id":2814584635,"node_id":"PRRC_kwDOQkbgjc6nwyc7","diff_hunk":"@@ -0,0 +1,475 @@\n+package main\n+\n+import (\n+\t\"archive/tar\"\n+\t\"compress/gzip\"\n+\t\"crypto/sha256\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"path\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+type Contract struct {\n+\tContractVersion string   `json:\"contract_version\"`\n+\tMode            string   `json:\"mode\"`\n+\tRepo            string   `json:\"repo\"`\n+\tEpochSec        int64    `json:\"epoch_sec\"`\n+\tBaseRef         string   `json:\"base_ref\"`\n+\tHeadSHA         string   `json:\"head_sha\"`\n+\tWarningsCount   int      `json:\"warnings_count\"`\n+\tEvidence        Evidence `json:\"evidence\"`\n+\tTool            Tool     `json:\"tool\"`\n+}\n+\n+type Evidence struct {\n+\tRequired    bool   `json:\"required\"`\n+\tPresent     bool   `json:\"present\"`\n+\tBoundToHead bool   `json:\"bound_to_head\"`\n+\tPathPrefix  string `json:\"path_prefix\"`\n+}\n+\n+type Tool struct {\n+\tName    string `json:\"name\"`\n+\tVersion string `json:\"version\"`\n+\tBuild   string `json:\"build,omitempty\"`\n+}\n+\n+type VerifyReport struct {\n+\tContract *Contract\n+\n+\t// computed\n+\tComputedSHA256 map[string][32]byte\n+\n+\t// extracted raw files (needed for seal/checks)\n+\tSHA256SUMS     []byte\n+\tSHA256SUMSSeal []byte\n+\tWarningsTxt    []byte\n+\tEvidenceFiles  [][]byte\n+\n+\t// required layout presence\n+\tHasIndex          bool\n+\tHasContractJSON   bool\n+\tHasSHA256SUMS     bool\n+\tHasSHA256SUMSSeal bool\n+\tHasSeriesPatch    bool\n+\n+\t// evidence scan result\n+\tEvidencePresent     bool\n+\tEvidenceBoundToHead bool\n+\n+\t// captured gzip header (for post-check)\n+\tGzipModTime time.Time\n+\tGzipName    string\n+\tGzipComment string\n+\tGzipExtra   []byte\n+\tGzipOS      byte\n+}\n+\n+func VerifyBundlePath(path string) (*VerifyReport, error) {\n+\tf, err := os.Open(path)\n+\tif err != nil {\n+\t\treturn nil, WrapVError(E_PATH, path, err)\n+\t}\n+\tdefer f.Close()\n+\treturn VerifyBundle(f)\n+}\n+\n+func VerifyBundle(r io.Reader) (*VerifyReport, error) {\n+\trep, err := verifyReportFromStream(r)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif err := verifyPostConditions(rep); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn rep, nil\n+}\n+\n+func verifyReportFromStream(r io.Reader) (*VerifyReport, error) {\n+\trep := &VerifyReport{\n+\t\tComputedSHA256: make(map[string][32]byte),\n+\t}\n+\n+\tgz, err := gzip.NewReader(r)\n+\tif err != nil {\n+\t\treturn nil, WrapVError(E_GZIP, \"stream\", err)\n+\t}\n+\tdefer gz.Close()\n+\n+\t// Capture gzip header\n+\trep.GzipModTime = gz.Header.ModTime\n+\trep.GzipName = gz.Header.Name\n+\trep.GzipComment = gz.Header.Comment\n+\trep.GzipExtra = gz.Header.Extra\n+\trep.GzipOS = gz.Header.OS\n+\n+\ttr := tar.NewReader(gz)\n+\tvar prevNameCanon string\n+\tvar seenFirst bool\n+\tvar seenSec int64\n+\n+\tfor {\n+\t\thdr, err := tr.Next()\n+\t\tif err == io.EOF {\n+\t\t\tbreak\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn nil, WrapVError(E_GZIP, \"tar stream corrupted\", err)\n+\t\t}\n+\n+\t\tname := hdr.Name\n+\n+\t\tif err := validateTarOrder(name, prevNameCanon, seenFirst); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tprevNameCanon = name\n+\t\tseenFirst = true\n+\n+\t\tif err := validateTarPath(name, hdr.Typeflag); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarType(name, hdr.Typeflag); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarIdentity(name, hdr); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarTime(name, hdr, &seenSec); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarPAX(name, hdr); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\tupdateLayoutPresence(name, hdr, rep)\n+\n+\t\tif err := processEntryContent(tr, hdr, rep); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\treturn rep, nil\n+}\n+\n+func validateTarOrder(name, prev string, seenFirst bool) error {\n+\tif seenFirst && name < prev {\n+\t\treturn NewVError(E_ORDER, name, fmt.Sprintf(\"is not sorted (prev: %s)\", prev))\n+\t}\n+\treturn nil\n+}\n+\n+func validateTarPath(name string, typeFlag byte) error {\n+\tif strings.HasPrefix(name, \"/\") {\n+\t\treturn NewVError(E_PATH, name, \"absolute path forbidden\")\n+\t}\n+\tif strings.Contains(name, \"\\x00\") {\n+\t\treturn NewVError(E_PATH, name, \"contains NUL char\")\n+\t}\n+\tif strings.Contains(name, \"\\\\\") {\n+\t\treturn NewVError(E_PATH, name, \"contains backslash\")\n+\t}\n+\tclean := path.Clean(name)\n+\tif clean == \"..\" || strings.HasPrefix(clean, \"../\") {\n+\t\treturn NewVError(E_PATH, name, \"parent traversal prohibited\")\n+\t}\n+\n+\t// Normalize check\n+\tnormalized := clean\n+\tif typeFlag == tar.TypeDir && !strings.HasSuffix(normalized, \"/\") {\n+\t\tif name != clean && name != clean+\"/\" {\n+\t\t\treturn NewVError(E_PATH, name, \"path not normalized\")\n+\t\t}\n+\t} else {\n+\t\tif name != clean {\n+\t\t\treturn NewVError(E_PATH, name, \"path not normalized\")\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func validateTarType(name string, flag byte) error {\n+\tswitch flag {\n+\tcase tar.TypeDir, tar.TypeReg, tar.TypeSymlink:\n+\t\treturn nil\n+\tdefault:\n+\t\treturn NewVError(E_TYPE, name, fmt.Sprintf(\"forbidden type flag: %c\", flag))\n+\t}\n+}\n+\n+func validateTarIdentity(name string, hdr *tar.Header) error {\n+\tif hdr.Uid != 0 || hdr.Gid != 0 {\n+\t\treturn NewVError(E_IDENTITY, name, fmt.Sprintf(\"non-zero uid/gid: %d/%d\", hdr.Uid, hdr.Gid))\n+\t}\n+\tif hdr.Uname != \"\" || hdr.Gname != \"\" {\n+\t\treturn NewVError(E_IDENTITY, name, fmt.Sprintf(\"non-empty uname/gname: %q/%q\", hdr.Uname, hdr.Gname))\n+\t}\n+\n+\t// Phase 7.6: Mode Normalization\n+\tmode := hdr.Mode & 0777\n+\tswitch hdr.Typeflag {\n+\tcase tar.TypeDir:\n+\t\tif mode != 0755 {\n+\t\t\treturn NewVError(E_IDENTITY, name, fmt.Sprintf(\"dir mode must be 0755 (got %o)\", mode))\n+\t\t}\n+\tcase tar.TypeReg:\n+\t\t// Check for executable bit in git's bitmask sense\n+\t\t// If executable (0755) or regular (0644)\n+\t\tif mode != 0644 && mode != 0755 {\n+\t\t\treturn NewVError(E_IDENTITY, name, fmt.Sprintf(\"regular file mode must be 0644 or 0755 (got %o)\", mode))\n+\t\t}\n+\tcase tar.TypeSymlink:\n+\t\t// Symlink mode is NOT validated (Phase 7.6)\n+\t}\n+\n+\treturn nil\n+}\n+\n+func validateTarTime(name string, hdr *tar.Header, seenSec *int64) error {\n+\tts := hdr.ModTime\n+\tif ts.Nanosecond() != 0 {\n+\t\treturn NewVError(E_TIME, name, \"non-zero nanoseconds forbidden\")\n+\t}\n+\tif *seenSec == 0 {\n+\t\t*seenSec = ts.Unix()\n+\t} else {\n+\t\tif ts.Unix() != *seenSec {\n+\t\t\treturn NewVError(E_TIME, name, fmt.Sprintf(\"mtime mismatch (expected %d, got %d)\", *seenSec, ts.Unix()))\n+\t\t}\n+\t}","path":"cmd/reviewbundle/verify.go","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"861ea41442259d138397665f9e13df7b80d7e3be","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"`validateTarTime` enforces that all tar entry mtimes are identical, but it never checks that the mtime matches the contract epoch (`contract.epoch_sec`). This allows bundles to pass verification even if tar header mtimes disagree with the declared epoch, which violates the contract.\n\nCompare each entry’s `hdr.ModTime.Unix()` (or the first-seen value) against `rep.Contract.EpochSec` during verification.\n```suggestion\nfunc validateTarTime(name string, hdr *tar.Header, seenSec *int64, epochSec int64) error {\n\tts := hdr.ModTime\n\tif ts.Nanosecond() != 0 {\n\t\treturn NewVError(E_TIME, name, \"non-zero nanoseconds forbidden\")\n\t}\n\n\tentrySec := ts.Unix()\n\n\t// If a contract epoch is provided, enforce that the entry mtime matches it.\n\tif epochSec != 0 && entrySec != epochSec {\n\t\treturn NewVError(\n\t\t\tE_TIME,\n\t\t\tname,\n\t\t\tfmt.Sprintf(\"mtime mismatch with contract epoch (expected %d, got %d)\", epochSec, entrySec),\n\t\t)\n\t}\n\n\t// Preserve invariant that all entries share the same mtime.\n\tif *seenSec == 0 {\n\t\tif epochSec != 0 {\n\t\t\t*seenSec = epochSec\n\t\t} else {\n\t\t\t*seenSec = entrySec\n\t\t}\n\t} else {\n\t\tif entrySec != *seenSec {\n\t\t\treturn NewVError(\n\t\t\t\tE_TIME,\n\t\t\t\tname,\n\t\t\t\tfmt.Sprintf(\"mtime mismatch (expected %d, got %d)\", *seenSec, entrySec),\n\t\t\t)\n\t\t}\n\t}\n```","created_at":"2026-02-17T01:32:01Z","updated_at":"2026-02-17T01:32:04Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814584635","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584635"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814584635"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584635/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":232,"original_start_line":230,"start_side":"RIGHT","line":243,"original_line":241,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":241,"position":243,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584642","pull_request_review_id":3811169344,"id":2814584642,"node_id":"PRRC_kwDOQkbgjc6nwydC","diff_hunk":"@@ -0,0 +1,475 @@\n+package main\n+\n+import (\n+\t\"archive/tar\"\n+\t\"compress/gzip\"\n+\t\"crypto/sha256\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"path\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+type Contract struct {\n+\tContractVersion string   `json:\"contract_version\"`\n+\tMode            string   `json:\"mode\"`\n+\tRepo            string   `json:\"repo\"`\n+\tEpochSec        int64    `json:\"epoch_sec\"`\n+\tBaseRef         string   `json:\"base_ref\"`\n+\tHeadSHA         string   `json:\"head_sha\"`\n+\tWarningsCount   int      `json:\"warnings_count\"`\n+\tEvidence        Evidence `json:\"evidence\"`\n+\tTool            Tool     `json:\"tool\"`\n+}\n+\n+type Evidence struct {\n+\tRequired    bool   `json:\"required\"`\n+\tPresent     bool   `json:\"present\"`\n+\tBoundToHead bool   `json:\"bound_to_head\"`\n+\tPathPrefix  string `json:\"path_prefix\"`\n+}\n+\n+type Tool struct {\n+\tName    string `json:\"name\"`\n+\tVersion string `json:\"version\"`\n+\tBuild   string `json:\"build,omitempty\"`\n+}\n+\n+type VerifyReport struct {\n+\tContract *Contract\n+\n+\t// computed\n+\tComputedSHA256 map[string][32]byte\n+\n+\t// extracted raw files (needed for seal/checks)\n+\tSHA256SUMS     []byte\n+\tSHA256SUMSSeal []byte\n+\tWarningsTxt    []byte\n+\tEvidenceFiles  [][]byte\n+\n+\t// required layout presence\n+\tHasIndex          bool\n+\tHasContractJSON   bool\n+\tHasSHA256SUMS     bool\n+\tHasSHA256SUMSSeal bool\n+\tHasSeriesPatch    bool\n+\n+\t// evidence scan result\n+\tEvidencePresent     bool\n+\tEvidenceBoundToHead bool\n+\n+\t// captured gzip header (for post-check)\n+\tGzipModTime time.Time\n+\tGzipName    string\n+\tGzipComment string\n+\tGzipExtra   []byte\n+\tGzipOS      byte\n+}\n+\n+func VerifyBundlePath(path string) (*VerifyReport, error) {\n+\tf, err := os.Open(path)\n+\tif err != nil {\n+\t\treturn nil, WrapVError(E_PATH, path, err)\n+\t}\n+\tdefer f.Close()\n+\treturn VerifyBundle(f)\n+}\n+\n+func VerifyBundle(r io.Reader) (*VerifyReport, error) {\n+\trep, err := verifyReportFromStream(r)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif err := verifyPostConditions(rep); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn rep, nil\n+}\n+\n+func verifyReportFromStream(r io.Reader) (*VerifyReport, error) {\n+\trep := &VerifyReport{\n+\t\tComputedSHA256: make(map[string][32]byte),\n+\t}\n+\n+\tgz, err := gzip.NewReader(r)\n+\tif err != nil {\n+\t\treturn nil, WrapVError(E_GZIP, \"stream\", err)\n+\t}\n+\tdefer gz.Close()\n+\n+\t// Capture gzip header\n+\trep.GzipModTime = gz.Header.ModTime\n+\trep.GzipName = gz.Header.Name\n+\trep.GzipComment = gz.Header.Comment\n+\trep.GzipExtra = gz.Header.Extra\n+\trep.GzipOS = gz.Header.OS\n+\n+\ttr := tar.NewReader(gz)\n+\tvar prevNameCanon string\n+\tvar seenFirst bool\n+\tvar seenSec int64\n+\n+\tfor {\n+\t\thdr, err := tr.Next()\n+\t\tif err == io.EOF {\n+\t\t\tbreak\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn nil, WrapVError(E_GZIP, \"tar stream corrupted\", err)\n+\t\t}\n+\n+\t\tname := hdr.Name\n+\n+\t\tif err := validateTarOrder(name, prevNameCanon, seenFirst); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tprevNameCanon = name\n+\t\tseenFirst = true\n+\n+\t\tif err := validateTarPath(name, hdr.Typeflag); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarType(name, hdr.Typeflag); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarIdentity(name, hdr); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarTime(name, hdr, &seenSec); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarPAX(name, hdr); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\tupdateLayoutPresence(name, hdr, rep)\n+\n+\t\tif err := processEntryContent(tr, hdr, rep); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\treturn rep, nil\n+}\n+\n+func validateTarOrder(name, prev string, seenFirst bool) error {\n+\tif seenFirst && name < prev {\n+\t\treturn NewVError(E_ORDER, name, fmt.Sprintf(\"is not sorted (prev: %s)\", prev))\n+\t}\n+\treturn nil\n+}\n+\n+func validateTarPath(name string, typeFlag byte) error {\n+\tif strings.HasPrefix(name, \"/\") {\n+\t\treturn NewVError(E_PATH, name, \"absolute path forbidden\")\n+\t}\n+\tif strings.Contains(name, \"\\x00\") {\n+\t\treturn NewVError(E_PATH, name, \"contains NUL char\")\n+\t}\n+\tif strings.Contains(name, \"\\\\\") {\n+\t\treturn NewVError(E_PATH, name, \"contains backslash\")\n+\t}\n+\tclean := path.Clean(name)\n+\tif clean == \"..\" || strings.HasPrefix(clean, \"../\") {\n+\t\treturn NewVError(E_PATH, name, \"parent traversal prohibited\")\n+\t}\n+\n+\t// Normalize check\n+\tnormalized := clean\n+\tif typeFlag == tar.TypeDir && !strings.HasSuffix(normalized, \"/\") {\n+\t\tif name != clean && name != clean+\"/\" {\n+\t\t\treturn NewVError(E_PATH, name, \"path not normalized\")\n+\t\t}\n+\t} else {\n+\t\tif name != clean {\n+\t\t\treturn NewVError(E_PATH, name, \"path not normalized\")\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func validateTarType(name string, flag byte) error {\n+\tswitch flag {\n+\tcase tar.TypeDir, tar.TypeReg, tar.TypeSymlink:\n+\t\treturn nil\n+\tdefault:\n+\t\treturn NewVError(E_TYPE, name, fmt.Sprintf(\"forbidden type flag: %c\", flag))\n+\t}\n+}\n+\n+func validateTarIdentity(name string, hdr *tar.Header) error {\n+\tif hdr.Uid != 0 || hdr.Gid != 0 {\n+\t\treturn NewVError(E_IDENTITY, name, fmt.Sprintf(\"non-zero uid/gid: %d/%d\", hdr.Uid, hdr.Gid))\n+\t}\n+\tif hdr.Uname != \"\" || hdr.Gname != \"\" {\n+\t\treturn NewVError(E_IDENTITY, name, fmt.Sprintf(\"non-empty uname/gname: %q/%q\", hdr.Uname, hdr.Gname))\n+\t}\n+\n+\t// Phase 7.6: Mode Normalization\n+\tmode := hdr.Mode & 0777\n+\tswitch hdr.Typeflag {\n+\tcase tar.TypeDir:\n+\t\tif mode != 0755 {\n+\t\t\treturn NewVError(E_IDENTITY, name, fmt.Sprintf(\"dir mode must be 0755 (got %o)\", mode))\n+\t\t}\n+\tcase tar.TypeReg:\n+\t\t// Check for executable bit in git's bitmask sense\n+\t\t// If executable (0755) or regular (0644)\n+\t\tif mode != 0644 && mode != 0755 {\n+\t\t\treturn NewVError(E_IDENTITY, name, fmt.Sprintf(\"regular file mode must be 0644 or 0755 (got %o)\", mode))\n+\t\t}\n+\tcase tar.TypeSymlink:\n+\t\t// Symlink mode is NOT validated (Phase 7.6)\n+\t}\n+\n+\treturn nil\n+}\n+\n+func validateTarTime(name string, hdr *tar.Header, seenSec *int64) error {\n+\tts := hdr.ModTime\n+\tif ts.Nanosecond() != 0 {\n+\t\treturn NewVError(E_TIME, name, \"non-zero nanoseconds forbidden\")\n+\t}\n+\tif *seenSec == 0 {\n+\t\t*seenSec = ts.Unix()\n+\t} else {\n+\t\tif ts.Unix() != *seenSec {\n+\t\t\treturn NewVError(E_TIME, name, fmt.Sprintf(\"mtime mismatch (expected %d, got %d)\", *seenSec, ts.Unix()))\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func validateTarPAX(name string, hdr *tar.Header) error {\n+\tif len(hdr.PAXRecords) > 0 {\n+\t\tfor k := range hdr.PAXRecords {\n+\t\t\t// Phase 4.2: strict allowlist (path/linkpath only)\n+\t\t\tif k == \"path\" || k == \"linkpath\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif k == \"mtime\" || k == \"atime\" || k == \"ctime\" {\n+\t\t\t\treturn NewVError(E_PAX, name, \"forbidden PAX time key: \"+k)\n+\t\t\t}\n+\t\t\tif strings.HasPrefix(k, \"LIBARCHIVE.\") || strings.HasPrefix(k, \"SCHILY.xattr.\") {\n+\t\t\t\treturn NewVError(E_XATTR, name, \"xattr/provenance leak: \"+k)\n+\t\t\t}\n+\t\t\treturn NewVError(E_PAX, name, \"forbidden PAX key (not in allowlist): \"+k)\n+\t\t}\n+\t}\n+\tif len(hdr.Xattrs) > 0 {\n+\t\treturn NewVError(E_XATTR, name, \"xattr map present\")\n+\t}\n+\treturn nil\n+}\n+\n+func updateLayoutPresence(name string, hdr *tar.Header, rep *VerifyReport) {\n+\tswitch {\n+\tcase name == PathIndex:\n+\t\trep.HasIndex = true\n+\tcase name == PathContract:\n+\t\trep.HasContractJSON = true\n+\tcase name == PathSHA256SUMS:\n+\t\trep.HasSHA256SUMS = true\n+\tcase name == PathSHA256SUMSSeal:\n+\t\trep.HasSHA256SUMSSeal = true\n+\tcase name == PathSeriesPatch:\n+\t\trep.HasSeriesPatch = true\n+\tcase strings.HasPrefix(name, DirEvidence):\n+\t\tif hdr.Typeflag != tar.TypeDir {\n+\t\t\trep.EvidencePresent = true\n+\t\t}\n+\t}\n+}\n+\n+func processEntryContent(tr *tar.Reader, hdr *tar.Header, rep *VerifyReport) error {\n+\tif hdr.Typeflag == tar.TypeDir {\n+\t\treturn nil\n+\t}\n+\n+\tname := hdr.Name\n+\tvar hash [32]byte\n+\n+\tif hdr.Typeflag == tar.TypeSymlink {\n+\t\tif path.IsAbs(hdr.Linkname) || strings.Contains(hdr.Linkname, \"..\") {\n+\t\t\treturn NewVError(E_PATH, name, \"unsafe symlink target: \"+hdr.Linkname)\n+\t\t}\n+\t\tdata := []byte(\"symlink\\x00\" + hdr.Linkname)\n+\t\thash = sha256.Sum256(data)\n+\t} else {\n+\t\t// Regular file\n+\t\tisMeta := name == PathSHA256SUMS ||\n+\t\t\tname == PathSHA256SUMSSeal ||\n+\t\t\tname == PathContract ||\n+\t\t\tname == PathWarnings ||\n+\t\t\tstrings.HasPrefix(name, DirEvidence)\n+\n+\t\tif isMeta {\n+\t\t\t// Phase 7.5: 4MB limit for meta/evidence parsing\n+\t\t\tlr := io.LimitReader(tr, 4*1024*1024)\n+\t\t\tcontent, err := io.ReadAll(lr)\n+\t\t\tif err != nil {\n+\t\t\t\treturn WrapVError(E_GZIP, name, err)\n+\t\t\t}\n+\t\t\t// Check if we hit the limit\n+\t\t\tif int64(len(content)) == 4*1024*1024 {\n+\t\t\t\t// Peek one byte to see if there's more\n+\t\t\t\tvar b [1]byte\n+\t\t\t\tn, _ := tr.Read(b[:])\n+\t\t\t\tif n > 0 {\n+\t\t\t\t\t// We truncated. If it's evidence, we marks it as potentially incomplete/invalid for binding\n+\t\t\t\t\t// but we keep the truncated content for hash validation if it's already in SHA256SUMS.\n+\t\t\t\t\t// Actually, if it's truncated, SHA256 match will fail anyway if we hash the truncated bytes.\n+\t\t\t\t\t// The contract says: if >4MB, bound=false.\n+\t\t\t\t\tcontent = append(content, []byte(\"...[TRUNCATED]\")...)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\thash = sha256.Sum256(content)\n+\n+\t\t\tif err := storeMetaContent(name, content, rep); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t} else {\n+\t\t\th := sha256.New()\n+\t\t\tif _, err := io.Copy(h, tr); err != nil {\n+\t\t\t\treturn WrapVError(E_GZIP, name, err)\n+\t\t\t}\n+\t\t\tcopy(hash[:], h.Sum(nil))\n+\t\t}","path":"cmd/reviewbundle/verify.go","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"861ea41442259d138397665f9e13df7b80d7e3be","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"For meta/evidence entries you hash only the first 4MB (`io.LimitReader`) and, if truncated, you even mutate the captured content by appending `...[TRUNCATED]`. This makes `ComputedSHA256` differ from the actual file bytes in the tar stream, causing checksum verification to fail for any meta/evidence file >4MB.\n\nHash should always be computed over the full tar entry bytes (streaming), while separately capturing at most N bytes for parsing/binding decisions.","created_at":"2026-02-17T01:32:01Z","updated_at":"2026-02-17T01:32:05Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814584642","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584642"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814584642"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584642/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":310,"original_start_line":308,"start_side":"RIGHT","line":341,"original_line":339,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":339,"position":341,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584649","pull_request_review_id":3811169344,"id":2814584649,"node_id":"PRRC_kwDOQkbgjc6nwydJ","diff_hunk":"@@ -0,0 +1,475 @@\n+package main\n+\n+import (\n+\t\"archive/tar\"\n+\t\"compress/gzip\"\n+\t\"crypto/sha256\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"path\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+type Contract struct {\n+\tContractVersion string   `json:\"contract_version\"`\n+\tMode            string   `json:\"mode\"`\n+\tRepo            string   `json:\"repo\"`\n+\tEpochSec        int64    `json:\"epoch_sec\"`\n+\tBaseRef         string   `json:\"base_ref\"`\n+\tHeadSHA         string   `json:\"head_sha\"`\n+\tWarningsCount   int      `json:\"warnings_count\"`\n+\tEvidence        Evidence `json:\"evidence\"`\n+\tTool            Tool     `json:\"tool\"`\n+}\n+\n+type Evidence struct {\n+\tRequired    bool   `json:\"required\"`\n+\tPresent     bool   `json:\"present\"`\n+\tBoundToHead bool   `json:\"bound_to_head\"`\n+\tPathPrefix  string `json:\"path_prefix\"`\n+}\n+\n+type Tool struct {\n+\tName    string `json:\"name\"`\n+\tVersion string `json:\"version\"`\n+\tBuild   string `json:\"build,omitempty\"`\n+}\n+\n+type VerifyReport struct {\n+\tContract *Contract\n+\n+\t// computed\n+\tComputedSHA256 map[string][32]byte\n+\n+\t// extracted raw files (needed for seal/checks)\n+\tSHA256SUMS     []byte\n+\tSHA256SUMSSeal []byte\n+\tWarningsTxt    []byte\n+\tEvidenceFiles  [][]byte\n+\n+\t// required layout presence\n+\tHasIndex          bool\n+\tHasContractJSON   bool\n+\tHasSHA256SUMS     bool\n+\tHasSHA256SUMSSeal bool\n+\tHasSeriesPatch    bool\n+\n+\t// evidence scan result\n+\tEvidencePresent     bool\n+\tEvidenceBoundToHead bool\n+\n+\t// captured gzip header (for post-check)\n+\tGzipModTime time.Time\n+\tGzipName    string\n+\tGzipComment string\n+\tGzipExtra   []byte\n+\tGzipOS      byte\n+}\n+\n+func VerifyBundlePath(path string) (*VerifyReport, error) {\n+\tf, err := os.Open(path)\n+\tif err != nil {\n+\t\treturn nil, WrapVError(E_PATH, path, err)\n+\t}\n+\tdefer f.Close()\n+\treturn VerifyBundle(f)\n+}\n+\n+func VerifyBundle(r io.Reader) (*VerifyReport, error) {\n+\trep, err := verifyReportFromStream(r)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif err := verifyPostConditions(rep); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn rep, nil\n+}\n+\n+func verifyReportFromStream(r io.Reader) (*VerifyReport, error) {\n+\trep := &VerifyReport{\n+\t\tComputedSHA256: make(map[string][32]byte),\n+\t}\n+\n+\tgz, err := gzip.NewReader(r)\n+\tif err != nil {\n+\t\treturn nil, WrapVError(E_GZIP, \"stream\", err)\n+\t}\n+\tdefer gz.Close()\n+\n+\t// Capture gzip header\n+\trep.GzipModTime = gz.Header.ModTime\n+\trep.GzipName = gz.Header.Name\n+\trep.GzipComment = gz.Header.Comment\n+\trep.GzipExtra = gz.Header.Extra\n+\trep.GzipOS = gz.Header.OS\n+\n+\ttr := tar.NewReader(gz)\n+\tvar prevNameCanon string\n+\tvar seenFirst bool\n+\tvar seenSec int64\n+\n+\tfor {\n+\t\thdr, err := tr.Next()\n+\t\tif err == io.EOF {\n+\t\t\tbreak\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn nil, WrapVError(E_GZIP, \"tar stream corrupted\", err)\n+\t\t}\n+\n+\t\tname := hdr.Name\n+\n+\t\tif err := validateTarOrder(name, prevNameCanon, seenFirst); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tprevNameCanon = name\n+\t\tseenFirst = true\n+\n+\t\tif err := validateTarPath(name, hdr.Typeflag); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarType(name, hdr.Typeflag); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarIdentity(name, hdr); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarTime(name, hdr, &seenSec); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarPAX(name, hdr); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\tupdateLayoutPresence(name, hdr, rep)\n+\n+\t\tif err := processEntryContent(tr, hdr, rep); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\treturn rep, nil\n+}\n+\n+func validateTarOrder(name, prev string, seenFirst bool) error {\n+\tif seenFirst && name < prev {\n+\t\treturn NewVError(E_ORDER, name, fmt.Sprintf(\"is not sorted (prev: %s)\", prev))\n+\t}\n+\treturn nil\n+}\n+\n+func validateTarPath(name string, typeFlag byte) error {\n+\tif strings.HasPrefix(name, \"/\") {\n+\t\treturn NewVError(E_PATH, name, \"absolute path forbidden\")\n+\t}\n+\tif strings.Contains(name, \"\\x00\") {\n+\t\treturn NewVError(E_PATH, name, \"contains NUL char\")\n+\t}\n+\tif strings.Contains(name, \"\\\\\") {\n+\t\treturn NewVError(E_PATH, name, \"contains backslash\")\n+\t}\n+\tclean := path.Clean(name)\n+\tif clean == \"..\" || strings.HasPrefix(clean, \"../\") {\n+\t\treturn NewVError(E_PATH, name, \"parent traversal prohibited\")\n+\t}\n+\n+\t// Normalize check\n+\tnormalized := clean\n+\tif typeFlag == tar.TypeDir && !strings.HasSuffix(normalized, \"/\") {\n+\t\tif name != clean && name != clean+\"/\" {\n+\t\t\treturn NewVError(E_PATH, name, \"path not normalized\")\n+\t\t}\n+\t} else {\n+\t\tif name != clean {\n+\t\t\treturn NewVError(E_PATH, name, \"path not normalized\")\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func validateTarType(name string, flag byte) error {\n+\tswitch flag {\n+\tcase tar.TypeDir, tar.TypeReg, tar.TypeSymlink:\n+\t\treturn nil\n+\tdefault:\n+\t\treturn NewVError(E_TYPE, name, fmt.Sprintf(\"forbidden type flag: %c\", flag))\n+\t}\n+}\n+\n+func validateTarIdentity(name string, hdr *tar.Header) error {\n+\tif hdr.Uid != 0 || hdr.Gid != 0 {\n+\t\treturn NewVError(E_IDENTITY, name, fmt.Sprintf(\"non-zero uid/gid: %d/%d\", hdr.Uid, hdr.Gid))\n+\t}\n+\tif hdr.Uname != \"\" || hdr.Gname != \"\" {\n+\t\treturn NewVError(E_IDENTITY, name, fmt.Sprintf(\"non-empty uname/gname: %q/%q\", hdr.Uname, hdr.Gname))\n+\t}\n+\n+\t// Phase 7.6: Mode Normalization\n+\tmode := hdr.Mode & 0777\n+\tswitch hdr.Typeflag {\n+\tcase tar.TypeDir:\n+\t\tif mode != 0755 {\n+\t\t\treturn NewVError(E_IDENTITY, name, fmt.Sprintf(\"dir mode must be 0755 (got %o)\", mode))\n+\t\t}\n+\tcase tar.TypeReg:\n+\t\t// Check for executable bit in git's bitmask sense\n+\t\t// If executable (0755) or regular (0644)\n+\t\tif mode != 0644 && mode != 0755 {\n+\t\t\treturn NewVError(E_IDENTITY, name, fmt.Sprintf(\"regular file mode must be 0644 or 0755 (got %o)\", mode))\n+\t\t}\n+\tcase tar.TypeSymlink:\n+\t\t// Symlink mode is NOT validated (Phase 7.6)\n+\t}\n+\n+\treturn nil\n+}\n+\n+func validateTarTime(name string, hdr *tar.Header, seenSec *int64) error {\n+\tts := hdr.ModTime\n+\tif ts.Nanosecond() != 0 {\n+\t\treturn NewVError(E_TIME, name, \"non-zero nanoseconds forbidden\")\n+\t}\n+\tif *seenSec == 0 {\n+\t\t*seenSec = ts.Unix()\n+\t} else {\n+\t\tif ts.Unix() != *seenSec {\n+\t\t\treturn NewVError(E_TIME, name, fmt.Sprintf(\"mtime mismatch (expected %d, got %d)\", *seenSec, ts.Unix()))\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func validateTarPAX(name string, hdr *tar.Header) error {\n+\tif len(hdr.PAXRecords) > 0 {\n+\t\tfor k := range hdr.PAXRecords {\n+\t\t\t// Phase 4.2: strict allowlist (path/linkpath only)\n+\t\t\tif k == \"path\" || k == \"linkpath\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif k == \"mtime\" || k == \"atime\" || k == \"ctime\" {\n+\t\t\t\treturn NewVError(E_PAX, name, \"forbidden PAX time key: \"+k)\n+\t\t\t}\n+\t\t\tif strings.HasPrefix(k, \"LIBARCHIVE.\") || strings.HasPrefix(k, \"SCHILY.xattr.\") {\n+\t\t\t\treturn NewVError(E_XATTR, name, \"xattr/provenance leak: \"+k)\n+\t\t\t}\n+\t\t\treturn NewVError(E_PAX, name, \"forbidden PAX key (not in allowlist): \"+k)\n+\t\t}\n+\t}\n+\tif len(hdr.Xattrs) > 0 {\n+\t\treturn NewVError(E_XATTR, name, \"xattr map present\")\n+\t}\n+\treturn nil\n+}\n+\n+func updateLayoutPresence(name string, hdr *tar.Header, rep *VerifyReport) {\n+\tswitch {\n+\tcase name == PathIndex:\n+\t\trep.HasIndex = true\n+\tcase name == PathContract:\n+\t\trep.HasContractJSON = true\n+\tcase name == PathSHA256SUMS:\n+\t\trep.HasSHA256SUMS = true\n+\tcase name == PathSHA256SUMSSeal:\n+\t\trep.HasSHA256SUMSSeal = true\n+\tcase name == PathSeriesPatch:\n+\t\trep.HasSeriesPatch = true\n+\tcase strings.HasPrefix(name, DirEvidence):\n+\t\tif hdr.Typeflag != tar.TypeDir {\n+\t\t\trep.EvidencePresent = true\n+\t\t}\n+\t}\n+}\n+\n+func processEntryContent(tr *tar.Reader, hdr *tar.Header, rep *VerifyReport) error {\n+\tif hdr.Typeflag == tar.TypeDir {\n+\t\treturn nil\n+\t}\n+\n+\tname := hdr.Name\n+\tvar hash [32]byte\n+\n+\tif hdr.Typeflag == tar.TypeSymlink {\n+\t\tif path.IsAbs(hdr.Linkname) || strings.Contains(hdr.Linkname, \"..\") {","path":"cmd/reviewbundle/verify.go","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"861ea41442259d138397665f9e13df7b80d7e3be","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"`strings.Contains(hdr.Linkname, \"..\")` treats any `..` substring as unsafe. This can reject non-traversal symlink targets such as `file..bak`.\n\nConsider applying the same normalization logic as regular paths (`path.Clean`, then reject `..` or `../` prefixes) instead of substring matching.\n```suggestion\n\t\ttarget := path.Clean(hdr.Linkname)\n\t\tif path.IsAbs(target) || target == \"..\" || strings.HasPrefix(target, \"../\") {\n```","created_at":"2026-02-17T01:32:01Z","updated_at":"2026-02-17T01:32:05Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814584649","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584649"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814584649"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584649/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":297,"original_line":295,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":295,"position":297,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584663","pull_request_review_id":3811169344,"id":2814584663,"node_id":"PRRC_kwDOQkbgjc6nwydX","diff_hunk":"@@ -0,0 +1,475 @@\n+package main\n+\n+import (\n+\t\"archive/tar\"\n+\t\"compress/gzip\"\n+\t\"crypto/sha256\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"path\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+type Contract struct {\n+\tContractVersion string   `json:\"contract_version\"`\n+\tMode            string   `json:\"mode\"`\n+\tRepo            string   `json:\"repo\"`\n+\tEpochSec        int64    `json:\"epoch_sec\"`\n+\tBaseRef         string   `json:\"base_ref\"`\n+\tHeadSHA         string   `json:\"head_sha\"`\n+\tWarningsCount   int      `json:\"warnings_count\"`\n+\tEvidence        Evidence `json:\"evidence\"`\n+\tTool            Tool     `json:\"tool\"`\n+}\n+\n+type Evidence struct {\n+\tRequired    bool   `json:\"required\"`\n+\tPresent     bool   `json:\"present\"`\n+\tBoundToHead bool   `json:\"bound_to_head\"`\n+\tPathPrefix  string `json:\"path_prefix\"`\n+}\n+\n+type Tool struct {\n+\tName    string `json:\"name\"`\n+\tVersion string `json:\"version\"`\n+\tBuild   string `json:\"build,omitempty\"`\n+}\n+\n+type VerifyReport struct {\n+\tContract *Contract\n+\n+\t// computed\n+\tComputedSHA256 map[string][32]byte\n+\n+\t// extracted raw files (needed for seal/checks)\n+\tSHA256SUMS     []byte\n+\tSHA256SUMSSeal []byte\n+\tWarningsTxt    []byte\n+\tEvidenceFiles  [][]byte\n+\n+\t// required layout presence\n+\tHasIndex          bool\n+\tHasContractJSON   bool\n+\tHasSHA256SUMS     bool\n+\tHasSHA256SUMSSeal bool\n+\tHasSeriesPatch    bool\n+\n+\t// evidence scan result\n+\tEvidencePresent     bool\n+\tEvidenceBoundToHead bool\n+\n+\t// captured gzip header (for post-check)\n+\tGzipModTime time.Time\n+\tGzipName    string\n+\tGzipComment string\n+\tGzipExtra   []byte\n+\tGzipOS      byte\n+}\n+\n+func VerifyBundlePath(path string) (*VerifyReport, error) {\n+\tf, err := os.Open(path)\n+\tif err != nil {\n+\t\treturn nil, WrapVError(E_PATH, path, err)\n+\t}\n+\tdefer f.Close()\n+\treturn VerifyBundle(f)\n+}\n+\n+func VerifyBundle(r io.Reader) (*VerifyReport, error) {\n+\trep, err := verifyReportFromStream(r)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif err := verifyPostConditions(rep); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn rep, nil\n+}\n+\n+func verifyReportFromStream(r io.Reader) (*VerifyReport, error) {\n+\trep := &VerifyReport{\n+\t\tComputedSHA256: make(map[string][32]byte),\n+\t}\n+\n+\tgz, err := gzip.NewReader(r)\n+\tif err != nil {\n+\t\treturn nil, WrapVError(E_GZIP, \"stream\", err)\n+\t}\n+\tdefer gz.Close()\n+\n+\t// Capture gzip header\n+\trep.GzipModTime = gz.Header.ModTime\n+\trep.GzipName = gz.Header.Name\n+\trep.GzipComment = gz.Header.Comment\n+\trep.GzipExtra = gz.Header.Extra\n+\trep.GzipOS = gz.Header.OS\n+\n+\ttr := tar.NewReader(gz)\n+\tvar prevNameCanon string\n+\tvar seenFirst bool\n+\tvar seenSec int64\n+\n+\tfor {\n+\t\thdr, err := tr.Next()\n+\t\tif err == io.EOF {\n+\t\t\tbreak\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn nil, WrapVError(E_GZIP, \"tar stream corrupted\", err)\n+\t\t}\n+\n+\t\tname := hdr.Name\n+\n+\t\tif err := validateTarOrder(name, prevNameCanon, seenFirst); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tprevNameCanon = name\n+\t\tseenFirst = true\n+\n+\t\tif err := validateTarPath(name, hdr.Typeflag); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarType(name, hdr.Typeflag); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarIdentity(name, hdr); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarTime(name, hdr, &seenSec); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarPAX(name, hdr); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\tupdateLayoutPresence(name, hdr, rep)\n+\n+\t\tif err := processEntryContent(tr, hdr, rep); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\treturn rep, nil\n+}\n+\n+func validateTarOrder(name, prev string, seenFirst bool) error {\n+\tif seenFirst && name < prev {\n+\t\treturn NewVError(E_ORDER, name, fmt.Sprintf(\"is not sorted (prev: %s)\", prev))\n+\t}\n+\treturn nil\n+}\n+\n+func validateTarPath(name string, typeFlag byte) error {\n+\tif strings.HasPrefix(name, \"/\") {\n+\t\treturn NewVError(E_PATH, name, \"absolute path forbidden\")\n+\t}\n+\tif strings.Contains(name, \"\\x00\") {\n+\t\treturn NewVError(E_PATH, name, \"contains NUL char\")\n+\t}\n+\tif strings.Contains(name, \"\\\\\") {\n+\t\treturn NewVError(E_PATH, name, \"contains backslash\")\n+\t}\n+\tclean := path.Clean(name)\n+\tif clean == \"..\" || strings.HasPrefix(clean, \"../\") {\n+\t\treturn NewVError(E_PATH, name, \"parent traversal prohibited\")\n+\t}\n+\n+\t// Normalize check\n+\tnormalized := clean\n+\tif typeFlag == tar.TypeDir && !strings.HasSuffix(normalized, \"/\") {\n+\t\tif name != clean && name != clean+\"/\" {\n+\t\t\treturn NewVError(E_PATH, name, \"path not normalized\")\n+\t\t}\n+\t} else {\n+\t\tif name != clean {\n+\t\t\treturn NewVError(E_PATH, name, \"path not normalized\")\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func validateTarType(name string, flag byte) error {\n+\tswitch flag {\n+\tcase tar.TypeDir, tar.TypeReg, tar.TypeSymlink:\n+\t\treturn nil\n+\tdefault:\n+\t\treturn NewVError(E_TYPE, name, fmt.Sprintf(\"forbidden type flag: %c\", flag))\n+\t}\n+}\n+\n+func validateTarIdentity(name string, hdr *tar.Header) error {\n+\tif hdr.Uid != 0 || hdr.Gid != 0 {\n+\t\treturn NewVError(E_IDENTITY, name, fmt.Sprintf(\"non-zero uid/gid: %d/%d\", hdr.Uid, hdr.Gid))\n+\t}\n+\tif hdr.Uname != \"\" || hdr.Gname != \"\" {\n+\t\treturn NewVError(E_IDENTITY, name, fmt.Sprintf(\"non-empty uname/gname: %q/%q\", hdr.Uname, hdr.Gname))\n+\t}\n+\n+\t// Phase 7.6: Mode Normalization\n+\tmode := hdr.Mode & 0777\n+\tswitch hdr.Typeflag {\n+\tcase tar.TypeDir:\n+\t\tif mode != 0755 {\n+\t\t\treturn NewVError(E_IDENTITY, name, fmt.Sprintf(\"dir mode must be 0755 (got %o)\", mode))\n+\t\t}\n+\tcase tar.TypeReg:\n+\t\t// Check for executable bit in git's bitmask sense\n+\t\t// If executable (0755) or regular (0644)\n+\t\tif mode != 0644 && mode != 0755 {\n+\t\t\treturn NewVError(E_IDENTITY, name, fmt.Sprintf(\"regular file mode must be 0644 or 0755 (got %o)\", mode))\n+\t\t}\n+\tcase tar.TypeSymlink:\n+\t\t// Symlink mode is NOT validated (Phase 7.6)\n+\t}\n+\n+\treturn nil\n+}\n+\n+func validateTarTime(name string, hdr *tar.Header, seenSec *int64) error {\n+\tts := hdr.ModTime\n+\tif ts.Nanosecond() != 0 {\n+\t\treturn NewVError(E_TIME, name, \"non-zero nanoseconds forbidden\")\n+\t}\n+\tif *seenSec == 0 {\n+\t\t*seenSec = ts.Unix()\n+\t} else {\n+\t\tif ts.Unix() != *seenSec {\n+\t\t\treturn NewVError(E_TIME, name, fmt.Sprintf(\"mtime mismatch (expected %d, got %d)\", *seenSec, ts.Unix()))\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func validateTarPAX(name string, hdr *tar.Header) error {\n+\tif len(hdr.PAXRecords) > 0 {\n+\t\tfor k := range hdr.PAXRecords {\n+\t\t\t// Phase 4.2: strict allowlist (path/linkpath only)\n+\t\t\tif k == \"path\" || k == \"linkpath\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif k == \"mtime\" || k == \"atime\" || k == \"ctime\" {\n+\t\t\t\treturn NewVError(E_PAX, name, \"forbidden PAX time key: \"+k)\n+\t\t\t}\n+\t\t\tif strings.HasPrefix(k, \"LIBARCHIVE.\") || strings.HasPrefix(k, \"SCHILY.xattr.\") {\n+\t\t\t\treturn NewVError(E_XATTR, name, \"xattr/provenance leak: \"+k)\n+\t\t\t}\n+\t\t\treturn NewVError(E_PAX, name, \"forbidden PAX key (not in allowlist): \"+k)\n+\t\t}\n+\t}\n+\tif len(hdr.Xattrs) > 0 {\n+\t\treturn NewVError(E_XATTR, name, \"xattr map present\")\n+\t}\n+\treturn nil\n+}\n+\n+func updateLayoutPresence(name string, hdr *tar.Header, rep *VerifyReport) {\n+\tswitch {\n+\tcase name == PathIndex:\n+\t\trep.HasIndex = true\n+\tcase name == PathContract:\n+\t\trep.HasContractJSON = true\n+\tcase name == PathSHA256SUMS:\n+\t\trep.HasSHA256SUMS = true\n+\tcase name == PathSHA256SUMSSeal:\n+\t\trep.HasSHA256SUMSSeal = true\n+\tcase name == PathSeriesPatch:\n+\t\trep.HasSeriesPatch = true\n+\tcase strings.HasPrefix(name, DirEvidence):\n+\t\tif hdr.Typeflag != tar.TypeDir {\n+\t\t\trep.EvidencePresent = true\n+\t\t}\n+\t}\n+}\n+\n+func processEntryContent(tr *tar.Reader, hdr *tar.Header, rep *VerifyReport) error {\n+\tif hdr.Typeflag == tar.TypeDir {\n+\t\treturn nil\n+\t}\n+\n+\tname := hdr.Name\n+\tvar hash [32]byte\n+\n+\tif hdr.Typeflag == tar.TypeSymlink {\n+\t\tif path.IsAbs(hdr.Linkname) || strings.Contains(hdr.Linkname, \"..\") {\n+\t\t\treturn NewVError(E_PATH, name, \"unsafe symlink target: \"+hdr.Linkname)\n+\t\t}\n+\t\tdata := []byte(\"symlink\\x00\" + hdr.Linkname)\n+\t\thash = sha256.Sum256(data)\n+\t} else {\n+\t\t// Regular file\n+\t\tisMeta := name == PathSHA256SUMS ||\n+\t\t\tname == PathSHA256SUMSSeal ||\n+\t\t\tname == PathContract ||\n+\t\t\tname == PathWarnings ||\n+\t\t\tstrings.HasPrefix(name, DirEvidence)\n+\n+\t\tif isMeta {\n+\t\t\t// Phase 7.5: 4MB limit for meta/evidence parsing\n+\t\t\tlr := io.LimitReader(tr, 4*1024*1024)\n+\t\t\tcontent, err := io.ReadAll(lr)\n+\t\t\tif err != nil {\n+\t\t\t\treturn WrapVError(E_GZIP, name, err)\n+\t\t\t}\n+\t\t\t// Check if we hit the limit\n+\t\t\tif int64(len(content)) == 4*1024*1024 {\n+\t\t\t\t// Peek one byte to see if there's more\n+\t\t\t\tvar b [1]byte\n+\t\t\t\tn, _ := tr.Read(b[:])\n+\t\t\t\tif n > 0 {\n+\t\t\t\t\t// We truncated. If it's evidence, we marks it as potentially incomplete/invalid for binding\n+\t\t\t\t\t// but we keep the truncated content for hash validation if it's already in SHA256SUMS.\n+\t\t\t\t\t// Actually, if it's truncated, SHA256 match will fail anyway if we hash the truncated bytes.\n+\t\t\t\t\t// The contract says: if >4MB, bound=false.\n+\t\t\t\t\tcontent = append(content, []byte(\"...[TRUNCATED]\")...)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\thash = sha256.Sum256(content)\n+\n+\t\t\tif err := storeMetaContent(name, content, rep); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t} else {\n+\t\t\th := sha256.New()\n+\t\t\tif _, err := io.Copy(h, tr); err != nil {\n+\t\t\t\treturn WrapVError(E_GZIP, name, err)\n+\t\t\t}\n+\t\t\tcopy(hash[:], h.Sum(nil))\n+\t\t}\n+\t}\n+\n+\trep.ComputedSHA256[name] = hash\n+\treturn nil\n+}\n+\n+func storeMetaContent(name string, content []byte, rep *VerifyReport) error {\n+\tswitch name {\n+\tcase PathSHA256SUMS:\n+\t\trep.SHA256SUMS = content\n+\tcase PathSHA256SUMSSeal:\n+\t\trep.SHA256SUMSSeal = content\n+\tcase PathContract:\n+\t\tc, err := ParseContractJSON(content)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\trep.Contract = c\n+\tcase PathWarnings:\n+\t\trep.WarningsTxt = content\n+\tdefault:\n+\t\tif strings.HasPrefix(name, DirEvidence) {\n+\t\t\trep.EvidenceFiles = append(rep.EvidenceFiles, content)\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func verifyPostConditions(rep *VerifyReport) error {\n+\tif err := validateContractAndEpoch(rep); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := validateGzipHeader(rep); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := validateLayout(rep); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := validateManifest(rep); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := validateEvidenceBinding(rep); err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func validateContractAndEpoch(rep *VerifyReport) error {\n+\tif !rep.HasContractJSON {\n+\t\treturn NewVError(E_LAYOUT, PathContract, \"missing essential metadata\")\n+\t}\n+\tif rep.Contract == nil {\n+\t\treturn NewVError(E_CONTRACT, PathContract, \"failed to parse\")\n+\t}\n+\treturn ValidateContractV11(rep.Contract)\n+}\n+\n+func validateGzipHeader(rep *VerifyReport) error {\n+\tepoch := rep.Contract.EpochSec\n+\tif rep.GzipModTime.Unix() != epoch {\n+\t\treturn NewVError(E_GZIP, \"header\", fmt.Sprintf(\"mtime mismatch (header: %d, contract: %d)\", rep.GzipModTime.Unix(), epoch))\n+\t}\n+\t// Phase 7.2: strictly 255\n+\tif rep.GzipOS != 255 {\n+\t\treturn NewVError(E_GZIP, \"header\", fmt.Sprintf(\"OS byte must be 255 (got %d)\", rep.GzipOS))\n+\t}\n+\tif rep.GzipName != \"\" {\n+\t\treturn NewVError(E_GZIP, \"header\", \"Name must be empty\")\n+\t}\n+\tif rep.GzipComment != \"\" {\n+\t\treturn NewVError(E_GZIP, \"header\", \"Comment must be empty\")\n+\t}\n+\tif len(rep.GzipExtra) > 0 {\n+\t\treturn NewVError(E_GZIP, \"header\", \"Extra data must be empty\")\n+\t}\n+\treturn nil\n+}\n+\n+func validateLayout(rep *VerifyReport) error {\n+\tif !rep.HasIndex {\n+\t\treturn NewVError(E_LAYOUT, PathIndex, \"missing\")\n+\t}\n+\tif !rep.HasSHA256SUMS {\n+\t\treturn NewVError(E_LAYOUT, PathSHA256SUMS, \"missing\")\n+\t}\n+\tif !rep.HasSHA256SUMSSeal {\n+\t\treturn NewVError(E_LAYOUT, PathSHA256SUMSSeal, \"missing\")\n+\t}\n+\tif !rep.HasSeriesPatch {\n+\t\treturn NewVError(E_LAYOUT, PathSeriesPatch, \"missing\")\n+\t}\n+\tif !rep.EvidencePresent && rep.Contract.Evidence.Required {\n+\t\treturn NewVError(E_EVIDENCE, DirEvidence, \"required but missing\")\n+\t}\n+\treturn nil\n+}\n+\n+func validateManifest(rep *VerifyReport) error {\n+\tchecksums, err := ParseSHA256SUMS(rep.SHA256SUMS)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif err := VerifySHA256SUMSSeal(rep.SHA256SUMS, rep.SHA256SUMSSeal); err != nil {\n+\t\treturn err\n+\t}\n+\treturn VerifyChecksumCompleteness(checksums, rep.ComputedSHA256)\n+}\n+\n+func validateEvidenceBinding(rep *VerifyReport) error {\n+\tmode := rep.Contract.Mode\n+\theadSHA := rep.Contract.HeadSHA\n+\n+\tif mode == ModeStrict {\n+\t\tif !rep.EvidencePresent {\n+\t\t\treturn NewVError(E_EVIDENCE, \"strict_mode\", \"evidence files required in strict mode\")\n+\t\t}\n+\t\tbound := false\n+\t\tfor _, content := range rep.EvidenceFiles {\n+\t\t\tif strings.Contains(string(content), headSHA) {\n+\t\t\t\tbound = true\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tif !bound {\n+\t\t\treturn NewVError(E_EVIDENCE, \"binding\", fmt.Sprintf(\"no evidence file contains HEAD SHA %s\", headSHA))\n+\t\t}","path":"cmd/reviewbundle/verify.go","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"861ea41442259d138397665f9e13df7b80d7e3be","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"Strict evidence binding currently searches evidence *contents* for the full 40-char HEAD SHA. The repo’s prverify evidence uses short SHAs (e.g., `git sha: 2546018`) and filename suffixes, so strict-mode bundles will fail verification even when the correct evidence is present.\n\nBind/verify using a stable marker that exists in evidence (e.g., match `head_sha[:7]`/`[:12]` against the evidence filename or the `git sha:` line), and consider encoding whatever binding rule you choose into `contract.json` so verify can be purely contract-driven.","created_at":"2026-02-17T01:32:02Z","updated_at":"2026-02-17T01:32:05Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814584663","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584663"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814584663"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584663/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":461,"original_start_line":448,"start_side":"RIGHT","line":489,"original_line":465,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":465,"position":489,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584671","pull_request_review_id":3811169344,"id":2814584671,"node_id":"PRRC_kwDOQkbgjc6nwydf","diff_hunk":"@@ -0,0 +1,101 @@\n+# REVIEW BUNDLE CONTRACT v1.1\n+\n+## 1. Mission & Philosophy\n+Review Bundle は「監査に耐える契約成果物 (contract artifact)」である。\n+作成ツール (go / bash) によらず、同一入力からは常に同一の bundle (byte-identical) が生成されなければならない。\n+また、verify コマンドは bundle の内容のみから正当性を証明できなければならない。\n+\n+## 2. Canonical Structure (Layout)\n+Bundle MUST be a `.tar.gz` file containing the following structure:\n+\n+- `review/INDEX.md` : Human-readable summary\n+- `review/meta/contract.json` : Machine-readable metadata (version, mode, base/head, epoch, counts)\n+- `review/meta/SHA256SUMS` : Checksums of all files (excluding itself)\n+- `review/meta/SHA256SUMS.sha256` : Checksum of SHA256SUMS\n+- `review/patch/series.patch` : Full patch from base to head\n+- `review/evidence/**` : Proof of verification (strict mode: required)\n+- `review/files/**` : Source file snapshots\n+\n+## 3. Determinism Rules (MUST)\n+Output MUST be reproducible bit-for-bit given the same:\n+- Git references (HEAD, Base)\n+- Epoch timestamp (SOURCE_DATE_EPOCH or HEAD commit time)\n+\n+### 3.1. Timestamp Normalization\n+- **Epoch Source**:\n+  - If `SOURCE_DATE_EPOCH` env var is set, use it.\n+  - Else, use git HEAD commit time (`%ct`).\n+- **Gzip Header**:\n+  - ModTime = Epoch (matches source)\n+  - OS = 255 (unknown)\n+  - Name/Comment = Empty\n+- **Tar Header**:\n+  - MTime = Epoch (matches source)\n+  - AccessTime / ChangeTime MUST be zero (epoch 0) or omitted.\n+  - PAX atime/ctime/mtime MUST NOT appear in the archive.\n+\n+### 3.2. Entry Ordering\n+- All entries in the tarball MUST be sorted by their full path in **bytewise lexicographic order**.\n+\n+### 3.3. Identity Anonymization (No Host Leak)\n+- **User/Group**:\n+  - UID = 0\n+  - GID = 0\n+  - Uname = \"\" (empty)\n+  - Gname = \"\" (empty)\n+- **Permissions (Mode)**:\n+  - Directory = `0755`\n+  - Regular File = `0644`\n+  - Executable Regular File = `0755`\n+  - Symlink = (Not validated; implementation dependent)\n+- **Extended Attributes / PAX**:\n+  - **PAX Records**: Only `path` and `linkpath` keys are permitted.\n+  - **Forbidden PAX Keys**: `mtime`, `atime`, `ctime` MUST NOT be present.\n+  - **Forbidden Xattrs**: `LIBARCHIVE.*`, `SCHILY.xattr.*`, or any other extended attributes MUST NOT be present.\n+  - Verification MUST fail if any forbidden or unknown keys are found.\n+- **Paths**:\n+  - Absolute paths MUST NOT be present.\n+  - `../` (parent traversal) MUST NOT be present.\n+\n+## 4. Checksumming Rules (MUST)\n+Output MUST be verifiable via SHA256:\n+\n+- **Regular File**: `sha256(file_content_bytes)`\n+- **Symlink**: `sha256(\"symlink\\x00\" + target_path)`\n+- **Directory**: (Not checksummed individually; included in manifest via layout if needed)\n+\n+## 4. Evidence Binding\n+- **Strict Mode**:","path":"docs/ops/REVIEW_BUNDLE.md","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"861ea41442259d138397665f9e13df7b80d7e3be","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"Section numbering is inconsistent: both “Checksumming Rules” and “Evidence Binding” are labeled as `## 4.`. This makes the contract harder to reference unambiguously.\n\nRenumber the Evidence Binding section (and subsequent headings) to keep the document structure consistent.","created_at":"2026-02-17T01:32:02Z","updated_at":"2026-02-17T01:32:05Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814584671","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584671"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814584671"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584671/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":60,"original_start_line":60,"start_side":"RIGHT","line":68,"original_line":68,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":68,"position":68,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584679","pull_request_review_id":3811169344,"id":2814584679,"node_id":"PRRC_kwDOQkbgjc6nwydn","diff_hunk":"@@ -0,0 +1,310 @@\n+package main\n+\n+import (\n+\t\"archive/tar\"\n+\t\"compress/gzip\"\n+\t\"crypto/sha256\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+func CreateBundleUI(mode, outDir, repoDir string, stdout, stderr io.Writer) error {\n+\tepoch, err := ComputeEpochSec(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\theadSHA, err := getGitHeadSHA(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfmt.Fprintf(stdout, \"Creating bundle (mode=%s, epoch=%d, head=%s)\\n\", mode, epoch, headSHA[:12])\n+\n+\t// C4: Pre-checks\n+\tisDirty, err := isGitDirty(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif mode == ModeStrict {\n+\t\tif isDirty {\n+\t\t\treturn NewVError(E_CONTRACT, \"git\", \"repository is dirty (prohibited in strict mode)\")\n+\t\t}\n+\t\t// Evidence check will come in C5/C6\n+\t} else if mode == ModeWIP {\n+\t\tif isDirty {\n+\t\t\tfmt.Fprintln(stderr, \"WARN: repository is dirty\")\n+\t\t}\n+\t}\n+\n+\t// C4: contract.json generation\n+\tcontract := &Contract{\n+\t\tContractVersion: \"1.1\",\n+\t\tMode:            mode,\n+\t\tRepo:            \"veil-rs\", // Canonical\n+\t\tEpochSec:        epoch,\n+\t\tBaseRef:         \"main\", // Canonical entry\n+\t\tHeadSHA:         headSHA,\n+\t\tWarningsCount:   0,\n+\t\tEvidence: Evidence{\n+\t\t\tRequired:    mode == ModeStrict,\n+\t\t\tPresent:     false,\n+\t\t\tBoundToHead: false,\n+\t\t\tPathPrefix:  DirEvidence,\n+\t\t},\n+\t\tTool: Tool{\n+\t\t\tName:    \"reviewbundle\",\n+\t\t\tVersion: \"1.0.0\",\n+\t\t},\n+\t}\n+\n+\tif isDirty {\n+\t\tcontract.WarningsCount++\n+\t}\n+\n+\t// C5/C6: Actual bundle generation\n+\tpath, err := CreateBundle(contract, outDir, repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfmt.Fprintf(stdout, \"Bundle created: %s\\n\", path)\n+\treturn nil\n+}\n+\n+func CreateBundle(c *Contract, outDir, repoDir string) (string, error) {\n+\tif err := os.MkdirAll(outDir, 0755); err != nil {\n+\t\treturn \"\", WrapVError(E_PATH, outDir, err)\n+\t}\n+\n+\tts := time.Unix(c.EpochSec, 0).UTC().Format(\"20060102_150405\")\n+\tname := fmt.Sprintf(\"veil-rs_review_%s_%s_%s.tar.gz\", c.Mode, ts, c.HeadSHA[:12])\n+\toutPath := filepath.Join(outDir, name)\n+\n+\ttmpPath := outPath + \".tmp\"\n+\tf, err := os.Create(tmpPath)\n+\tif err != nil {\n+\t\treturn \"\", WrapVError(E_PATH, tmpPath, err)\n+\t}\n+\tdefer os.Remove(tmpPath)\n+\tdefer f.Close()\n+\n+\tgw := gzip.NewWriter(f)\n+\tgw.Header.ModTime = time.Unix(c.EpochSec, 0)\n+\tgw.Header.OS = 255\n+\tdefer gw.Close()\n+\n+\ttw := tar.NewWriter(gw)\n+\tdefer tw.Close()\n+\n+\t// 1. Gather files\n+\tfiles := make(map[string][]byte)\n+\n+\t// INDEX.md\n+\tfiles[PathIndex] = []byte(fmt.Sprintf(\"# Review Bundle\\n\\nMode: %s\\nEpoch: %d\\nHead: %s\\n\", c.Mode, c.EpochSec, c.HeadSHA))\n+\n+\t// patch/series.patch\n+\tpatch, err := getGitPatch(c.BaseRef, c.HeadSHA, repoDir)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tfiles[PathSeriesPatch] = patch\n+\n+\t// Evidence (Phase 7.5/8/9)\n+\tbound, evFiles, err := collectEvidence(c.HeadSHA, repoDir)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tif len(evFiles) > 0 {\n+\t\tc.Evidence.Present = true\n+\t\tc.Evidence.BoundToHead = bound\n+\t\tfor name, content := range evFiles {\n+\t\t\tfiles[name] = content\n+\t\t}\n+\t}\n+\n+\t// meta/contract.json (update with evidence findings)\n+\tcj, _ := json.MarshalIndent(c, \"\", \"  \")\n+\tfiles[PathContract] = cj\n+\n+\t// 2. Generate SHA256SUMS (C6)\n+\tvar manifestKeys []string\n+\tfor k := range files {\n+\t\tmanifestKeys = append(manifestKeys, k)\n+\t}\n+\tsort.Strings(manifestKeys)\n+\n+\tvar sumsBuilder strings.Builder\n+\tfor _, k := range manifestKeys {\n+\t\th := sha256.Sum256(files[k])\n+\t\tfmt.Fprintf(&sumsBuilder, \"%x  %s\\n\", h, k)\n+\t}\n+\tsums := []byte(sumsBuilder.String())\n+\tfiles[PathSHA256SUMS] = sums\n+\n+\t// seal\n+\tseal := sha256.Sum256(sums)\n+\tfiles[PathSHA256SUMSSeal] = []byte(fmt.Sprintf(\"%x  %s\\n\", seal, PathSHA256SUMS))\n+\n+\t// 3. Sort and write (C5)\n+\tvar keys []string\n+\tfor k := range files {\n+\t\tkeys = append(keys, k)\n+\t}\n+\tsort.Strings(keys)\n+\n+\tfor _, k := range keys {\n+\t\tcontent := files[k]\n+\t\thdr := &tar.Header{\n+\t\t\tName:     k,\n+\t\t\tSize:     int64(len(content)),\n+\t\t\tMode:     0644,\n+\t\t\tModTime:  time.Unix(c.EpochSec, 0),\n+\t\t\tTypeflag: tar.TypeReg,\n+\t\t\tUid:      0,\n+\t\t\tGid:      0,\n+\t\t\tUname:    \"\",\n+\t\t\tGname:    \"\",\n+\t\t\tFormat:   tar.FormatPAX,\n+\t\t\t// Phase 4.2/7.3: Explicitly zero extra times to avoid PAX mtime/atime/ctime\n+\t\t\tAccessTime: time.Time{},\n+\t\t\tChangeTime: time.Time{},\n+\t\t\tPAXRecords: nil,\n+\t\t}\n+\t\tif err := tw.WriteHeader(hdr); err != nil {\n+\t\t\treturn \"\", WrapVError(E_GZIP, k, err)\n+\t\t}\n+\t\tif _, err := tw.Write(content); err != nil {\n+\t\t\treturn \"\", WrapVError(E_GZIP, k, err)\n+\t\t}\n+\t}\n+\n+\ttw.Close()\n+\tgw.Close()\n+\tf.Close()\n+\n+\tif err := os.Rename(tmpPath, outPath); err != nil {\n+\t\treturn \"\", WrapVError(E_PATH, outPath, err)\n+\t}\n+\n+\t// 4. Self-Audit (C6)\n+\t_, err = VerifyBundlePath(outPath)\n+\tif err != nil {\n+\t\t// If verification fails, we keep the broken bundle for inspection but return error\n+\t\treturn outPath, fmt.Errorf(\"self-audit failed for %s: %w\", outPath, err)\n+\t}\n+\n+\treturn outPath, nil\n+}\n+\n+func getGitPatch(base, head, repoDir string) ([]byte, error) {\n+\tcmd := exec.Command(\"git\", \"format-patch\", \"--stdout\", base+\"..\"+head)\n+\tif repoDir != \"\" {\n+\t\tcmd.Dir = repoDir\n+\t}\n+\tout, err := cmd.Output()\n+\tif err != nil {\n+\t\treturn nil, WrapVError(E_CONTRACT, \"git format-patch\", err)\n+\t}\n+\treturn out, nil\n+}\n+\n+func ComputeEpochSec(repoDir string) (int64, error) {\n+\tif s := os.Getenv(\"SOURCE_DATE_EPOCH\"); s != \"\" {\n+\t\tsec, err := strconv.ParseInt(s, 10, 64)\n+\t\tif err == nil {\n+\t\t\treturn sec, nil\n+\t\t}\n+\t}\n+\n+\t// Fallback to git show -s --format=%ct HEAD\n+\tcmd := exec.Command(\"git\", \"show\", \"-s\", \"--format=%ct\", \"HEAD\")\n+\tif repoDir != \"\" {\n+\t\tcmd.Dir = repoDir\n+\t}\n+\tout, err := cmd.Output()\n+\tif err != nil {\n+\t\treturn 0, WrapVError(E_CONTRACT, \"git\", err)\n+\t}\n+\tsec, err := strconv.ParseInt(strings.TrimSpace(string(out)), 10, 64)\n+\tif err != nil {\n+\t\treturn 0, WrapVError(E_CONTRACT, \"git parse\", err)\n+\t}\n+\treturn sec, nil\n+}\n+\n+func getGitHeadSHA(repoDir string) (string, error) {\n+\tcmd := exec.Command(\"git\", \"rev-parse\", \"HEAD\")\n+\tif repoDir != \"\" {\n+\t\tcmd.Dir = repoDir\n+\t}\n+\tout, err := cmd.Output()\n+\tif err != nil {\n+\t\treturn \"\", WrapVError(E_CONTRACT, \"git rev-parse\", err)\n+\t}\n+\treturn strings.TrimSpace(string(out)), nil\n+}\n+\n+func collectEvidence(headSHA, repoDir string) (bool, map[string][]byte, error) {\n+\tevDir := \"docs/evidence/prverify\"\n+\tif repoDir != \"\" {\n+\t\tevDir = filepath.Join(repoDir, evDir)\n+\t}\n+\n+\tentries, err := os.ReadDir(evDir)\n+\tif err != nil {\n+\t\tif os.IsNotExist(err) {\n+\t\t\treturn false, nil, nil\n+\t\t}\n+\t\treturn false, nil, WrapVError(E_PATH, evDir, err)\n+\t}\n+\n+\tfiles := make(map[string][]byte)\n+\tbound := false\n+\n+\tfor _, e := range entries {\n+\t\tif e.IsDir() || !strings.HasPrefix(e.Name(), \"prverify_\") || !strings.HasSuffix(e.Name(), \".md\") {\n+\t\t\tcontinue\n+\t\t}\n+\t\tpath := filepath.Join(evDir, e.Name())\n+\t\tcontent, err := os.ReadFile(path)\n+\t\tif err != nil {\n+\t\t\treturn false, nil, WrapVError(E_PATH, path, err)\n+\t\t}\n+\n+\t\t// Bundle path: review/evidence/prverify/prverify_...\n+\t\tbundlePath := filepath.Join(DirEvidence, \"prverify\", e.Name())\n+\t\tfiles[bundlePath] = content\n+\n+\t\t// Phase 7.5: 4MB limit check for binding\n+\t\tif len(content) > 4*1024*1024 {\n+\t\t\tcontinue // Too big to trust for binding\n+\t\t}\n+\t\tif strings.Contains(string(content), headSHA) {\n+\t\t\tbound = true\n+\t\t}","path":"cmd/reviewbundle/create.go","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"861ea41442259d138397665f9e13df7b80d7e3be","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"`collectEvidence` tries to determine binding by searching the evidence file contents for the full 40-char `headSHA`. The committed prverify evidence files in this repo use short SHAs (e.g., `git sha: 2546018`), so `BoundToHead` will almost never become true.\n\nBinding should be derived from a stable marker that actually exists in evidence (e.g., the filename suffix `_xxxxxxx.md`, or matching `git sha:` against `headSHA[:7]`/`[:12]`).","created_at":"2026-02-17T01:32:02Z","updated_at":"2026-02-17T01:32:05Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814584679","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584679"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814584679"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584679/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":288,"original_start_line":288,"start_side":"RIGHT","line":294,"original_line":294,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":294,"position":294,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584696","pull_request_review_id":3811169344,"id":2814584696,"node_id":"PRRC_kwDOQkbgjc6nwyd4","diff_hunk":"@@ -56,6 +56,15 @@\n           '';\n         };\n \n+        # Review Bundle CLI\n+        reviewbundlePkg = pkgs.buildGoModule {\n+          pname = \"reviewbundle\";\n+          version = \"1.0.0\";\n+          src = ./.;\n+          subPackages = [ \"cmd/reviewbundle\" ];\n+          vendorHash = null;","path":"flake.nix","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"861ea41442259d138397665f9e13df7b80d7e3be","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"`vendorHash = null` will make `pkgs.buildGoModule` fail for `reviewbundle` because the module has external dependencies (see `go.mod`), so `nix run .#reviewbundle` / `nix build .#reviewbundle` won’t work as declared.\n\nPin the correct `vendorHash` (run a build once to get the suggested hash) so the flake package/app is actually buildable and reproducible.\n```suggestion\n          # TODO: replace this placeholder with the hash suggested by `nix build .#reviewbundle`\n          vendorHash = \"sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\";\n```","created_at":"2026-02-17T01:32:02Z","updated_at":"2026-02-17T01:32:05Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814584696","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584696"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814584696"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584696/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":65,"original_line":65,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":10,"position":10,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584710","pull_request_review_id":3811169344,"id":2814584710,"node_id":"PRRC_kwDOQkbgjc6nwyeG","diff_hunk":"@@ -0,0 +1,57 @@\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+func main() {\n+\tos.Exit(run(os.Args, os.Stdout, os.Stderr))\n+}\n+\n+func run(argv []string, stdout, stderr io.Writer) int {\n+\tif len(argv) < 2 {\n+\t\tusage(stderr)\n+\t\treturn 1\n+\t}\n+\n+\tcmd := argv[1]\n+\tswitch cmd {\n+\tcase \"verify\":\n+\t\tif len(argv) < 3 {\n+\t\t\tfmt.Fprintln(stderr, \"error: verify requires bundle path\")\n+\t\t\tusage(stderr)\n+\t\t\treturn 1\n+\t\t}\n+\t\tpath := argv[2]\n+\t\treport, err := VerifyBundlePath(path)\n+\t\tif err != nil {\n+\t\t\tfmt.Fprintln(stderr, err.Error())\n+\t\t\treturn 1\n+\t\t}\n+\t\tfmt.Fprintf(stdout, \"PASS: %s (mode=%s, epoch=%d)\\n\", path, report.Contract.Mode, report.Contract.EpochSec)\n+\t\treturn 0\n+\n+\tcase \"create\":\n+\t\t// TODO: flags for mode/out-dir\n+\t\tmode := \"wip\"\n+\t\toutDir := \".local/review-bundles\"\n+\t\tif err := CreateBundleUI(mode, outDir, \"\", stdout, stderr); err != nil {\n+\t\t\tfmt.Fprintln(stderr, err.Error())","path":"cmd/reviewbundle/main.go","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"861ea41442259d138397665f9e13df7b80d7e3be","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The `create` command ignores both CLI args and the legacy environment variables (mode/out dir/repo dir are hardcoded). This prevents `ops/ci/review_bundle.sh` from actually “translating legacy env vars” as claimed, and makes the CLI difficult to use non-interactively.\n\nAdd flag parsing (or env var support) for `--mode` and `--out-dir` at minimum, and pass `repoDir` explicitly when running outside the repo root.","created_at":"2026-02-17T01:32:02Z","updated_at":"2026-02-17T01:32:05Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814584710","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584710"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814584710"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584710/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":37,"original_start_line":36,"start_side":"RIGHT","line":68,"original_line":41,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":41,"position":68,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584722","pull_request_review_id":3811169344,"id":2814584722,"node_id":"PRRC_kwDOQkbgjc6nwyeS","diff_hunk":"@@ -0,0 +1,82 @@\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"os\"\n+\t\"strconv\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func TestVerify_DeterministicResultForSameInput(t *testing.T) {\n+\t// TODO: implement in C3/C5\n+}\n+","path":"cmd/reviewbundle/determinism_test.go","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"861ea41442259d138397665f9e13df7b80d7e3be","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"This test is currently a no-op and will always pass, which can give a false sense of coverage for determinism guarantees.\n\nEither implement the assertions (or remove the stub until it’s ready) so the suite only contains meaningful tests.\n```suggestion\n\n```","created_at":"2026-02-17T01:32:03Z","updated_at":"2026-02-17T01:32:03Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814584722","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584722"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814584722"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814584722/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":11,"original_start_line":11,"start_side":"RIGHT","line":14,"original_line":14,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":14,"position":14,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814607380","pull_request_review_id":3811199286,"id":2814607380,"node_id":"PRRC_kwDOQkbgjc6nw4AU","diff_hunk":"@@ -0,0 +1,39 @@\n+package main\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"io\"\n+)\n+\n+func ParseContractJSON(b []byte) (*Contract, error) {\n+\tvar c Contract\n+\tif err := json.Unmarshal(b, &c); err != nil {\n+\t\treturn nil, WrapVError(E_CONTRACT, \"contract.json\", err)\n+\t}\n+\treturn &c, nil\n+}\n+\n+func ParseContract(r io.Reader) (*Contract, error) {\n+\tb, err := io.ReadAll(r)\n+\tif err != nil {\n+\t\treturn nil, WrapVError(E_CONTRACT, \"contract.json\", err)\n+\t}\n+\treturn ParseContractJSON(b)\n+}\n+\n+func ValidateContractV11(c *Contract) error {\n+\tif c.ContractVersion != \"1.1\" {\n+\t\treturn NewVError(E_CONTRACT, \"contract.json\", fmt.Sprintf(\"unsupported version: %s (want 1.1)\", c.ContractVersion))\n+\t}\n+\tif c.Mode != \"strict\" && c.Mode != \"wip\" {\n+\t\treturn NewVError(E_CONTRACT, \"contract.json\", fmt.Sprintf(\"invalid mode: %s\", c.Mode))\n+\t}\n+\tif c.EpochSec <= 0 {\n+\t\treturn NewVError(E_CONTRACT, \"contract.json\", \"invalid epoch_sec\")\n+\t}\n+\tif len(c.HeadSHA) != 40 {\n+\t\treturn NewVError(E_CONTRACT, \"contract.json\", \"invalid head_sha (want 40 hex chars)\")\n+\t}","path":"cmd/reviewbundle/contract.go","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"41a44446285de74eff61cdd07d2a3837665be82a","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The HeadSHA validation only checks length but doesn't verify the string contains valid hexadecimal characters. A string with 40 arbitrary characters would pass validation. Consider adding hex validation using hex.DecodeString or a regex pattern check.","created_at":"2026-02-17T01:43:15Z","updated_at":"2026-02-17T01:43:18Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814607380","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814607380"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814607380"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814607380/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":35,"original_start_line":35,"start_side":"RIGHT","line":37,"original_line":37,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":37,"position":37,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814607390","pull_request_review_id":3811199286,"id":2814607390,"node_id":"PRRC_kwDOQkbgjc6nw4Ae","diff_hunk":"@@ -0,0 +1,310 @@\n+package main\n+\n+import (\n+\t\"archive/tar\"\n+\t\"compress/gzip\"\n+\t\"crypto/sha256\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+func CreateBundleUI(mode, outDir, repoDir string, stdout, stderr io.Writer) error {\n+\tepoch, err := ComputeEpochSec(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\theadSHA, err := getGitHeadSHA(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfmt.Fprintf(stdout, \"Creating bundle (mode=%s, epoch=%d, head=%s)\\n\", mode, epoch, headSHA[:12])\n+\n+\t// C4: Pre-checks\n+\tisDirty, err := isGitDirty(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif mode == ModeStrict {\n+\t\tif isDirty {\n+\t\t\treturn NewVError(E_CONTRACT, \"git\", \"repository is dirty (prohibited in strict mode)\")\n+\t\t}\n+\t\t// Evidence check will come in C5/C6\n+\t} else if mode == ModeWIP {\n+\t\tif isDirty {\n+\t\t\tfmt.Fprintln(stderr, \"WARN: repository is dirty\")\n+\t\t}\n+\t}\n+\n+\t// C4: contract.json generation\n+\tcontract := &Contract{\n+\t\tContractVersion: \"1.1\",\n+\t\tMode:            mode,\n+\t\tRepo:            \"veil-rs\", // Canonical\n+\t\tEpochSec:        epoch,\n+\t\tBaseRef:         \"main\", // Canonical entry\n+\t\tHeadSHA:         headSHA,\n+\t\tWarningsCount:   0,\n+\t\tEvidence: Evidence{\n+\t\t\tRequired:    mode == ModeStrict,\n+\t\t\tPresent:     false,\n+\t\t\tBoundToHead: false,\n+\t\t\tPathPrefix:  DirEvidence,\n+\t\t},\n+\t\tTool: Tool{\n+\t\t\tName:    \"reviewbundle\",\n+\t\t\tVersion: \"1.0.0\",\n+\t\t},\n+\t}\n+\n+\tif isDirty {\n+\t\tcontract.WarningsCount++\n+\t}\n+\n+\t// C5/C6: Actual bundle generation\n+\tpath, err := CreateBundle(contract, outDir, repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfmt.Fprintf(stdout, \"Bundle created: %s\\n\", path)\n+\treturn nil\n+}\n+\n+func CreateBundle(c *Contract, outDir, repoDir string) (string, error) {\n+\tif err := os.MkdirAll(outDir, 0755); err != nil {\n+\t\treturn \"\", WrapVError(E_PATH, outDir, err)\n+\t}\n+\n+\tts := time.Unix(c.EpochSec, 0).UTC().Format(\"20060102_150405\")\n+\tname := fmt.Sprintf(\"veil-rs_review_%s_%s_%s.tar.gz\", c.Mode, ts, c.HeadSHA[:12])\n+\toutPath := filepath.Join(outDir, name)\n+\n+\ttmpPath := outPath + \".tmp\"\n+\tf, err := os.Create(tmpPath)\n+\tif err != nil {\n+\t\treturn \"\", WrapVError(E_PATH, tmpPath, err)\n+\t}\n+\tdefer os.Remove(tmpPath)\n+\tdefer f.Close()\n+\n+\tgw := gzip.NewWriter(f)\n+\tgw.Header.ModTime = time.Unix(c.EpochSec, 0)\n+\tgw.Header.OS = 255\n+\tdefer gw.Close()\n+\n+\ttw := tar.NewWriter(gw)\n+\tdefer tw.Close()\n+\n+\t// 1. Gather files\n+\tfiles := make(map[string][]byte)\n+\n+\t// INDEX.md\n+\tfiles[PathIndex] = []byte(fmt.Sprintf(\"# Review Bundle\\n\\nMode: %s\\nEpoch: %d\\nHead: %s\\n\", c.Mode, c.EpochSec, c.HeadSHA))\n+\n+\t// patch/series.patch\n+\tpatch, err := getGitPatch(c.BaseRef, c.HeadSHA, repoDir)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tfiles[PathSeriesPatch] = patch\n+\n+\t// Evidence (Phase 7.5/8/9)\n+\tbound, evFiles, err := collectEvidence(c.HeadSHA, repoDir)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tif len(evFiles) > 0 {\n+\t\tc.Evidence.Present = true\n+\t\tc.Evidence.BoundToHead = bound\n+\t\tfor name, content := range evFiles {\n+\t\t\tfiles[name] = content\n+\t\t}\n+\t}\n+\n+\t// meta/contract.json (update with evidence findings)\n+\tcj, _ := json.MarshalIndent(c, \"\", \"  \")\n+\tfiles[PathContract] = cj\n+\n+\t// 2. Generate SHA256SUMS (C6)\n+\tvar manifestKeys []string\n+\tfor k := range files {\n+\t\tmanifestKeys = append(manifestKeys, k)\n+\t}\n+\tsort.Strings(manifestKeys)\n+\n+\tvar sumsBuilder strings.Builder\n+\tfor _, k := range manifestKeys {\n+\t\th := sha256.Sum256(files[k])\n+\t\tfmt.Fprintf(&sumsBuilder, \"%x  %s\\n\", h, k)\n+\t}\n+\tsums := []byte(sumsBuilder.String())\n+\tfiles[PathSHA256SUMS] = sums\n+\n+\t// seal\n+\tseal := sha256.Sum256(sums)\n+\tfiles[PathSHA256SUMSSeal] = []byte(fmt.Sprintf(\"%x  %s\\n\", seal, PathSHA256SUMS))\n+\n+\t// 3. Sort and write (C5)\n+\tvar keys []string\n+\tfor k := range files {\n+\t\tkeys = append(keys, k)\n+\t}\n+\tsort.Strings(keys)\n+\n+\tfor _, k := range keys {\n+\t\tcontent := files[k]\n+\t\thdr := &tar.Header{\n+\t\t\tName:     k,\n+\t\t\tSize:     int64(len(content)),\n+\t\t\tMode:     0644,\n+\t\t\tModTime:  time.Unix(c.EpochSec, 0),\n+\t\t\tTypeflag: tar.TypeReg,\n+\t\t\tUid:      0,\n+\t\t\tGid:      0,\n+\t\t\tUname:    \"\",\n+\t\t\tGname:    \"\",\n+\t\t\tFormat:   tar.FormatPAX,\n+\t\t\t// Phase 4.2/7.3: Explicitly zero extra times to avoid PAX mtime/atime/ctime\n+\t\t\tAccessTime: time.Time{},\n+\t\t\tChangeTime: time.Time{},\n+\t\t\tPAXRecords: nil,\n+\t\t}\n+\t\tif err := tw.WriteHeader(hdr); err != nil {\n+\t\t\treturn \"\", WrapVError(E_GZIP, k, err)\n+\t\t}\n+\t\tif _, err := tw.Write(content); err != nil {\n+\t\t\treturn \"\", WrapVError(E_GZIP, k, err)\n+\t\t}\n+\t}\n+\n+\ttw.Close()\n+\tgw.Close()\n+\tf.Close()\n+\n+\tif err := os.Rename(tmpPath, outPath); err != nil {\n+\t\treturn \"\", WrapVError(E_PATH, outPath, err)\n+\t}\n+\n+\t// 4. Self-Audit (C6)\n+\t_, err = VerifyBundlePath(outPath)\n+\tif err != nil {\n+\t\t// If verification fails, we keep the broken bundle for inspection but return error\n+\t\treturn outPath, fmt.Errorf(\"self-audit failed for %s: %w\", outPath, err)\n+\t}\n+\n+\treturn outPath, nil\n+}\n+\n+func getGitPatch(base, head, repoDir string) ([]byte, error) {\n+\tcmd := exec.Command(\"git\", \"format-patch\", \"--stdout\", base+\"..\"+head)\n+\tif repoDir != \"\" {\n+\t\tcmd.Dir = repoDir\n+\t}\n+\tout, err := cmd.Output()\n+\tif err != nil {\n+\t\treturn nil, WrapVError(E_CONTRACT, \"git format-patch\", err)\n+\t}\n+\treturn out, nil\n+}\n+\n+func ComputeEpochSec(repoDir string) (int64, error) {\n+\tif s := os.Getenv(\"SOURCE_DATE_EPOCH\"); s != \"\" {\n+\t\tsec, err := strconv.ParseInt(s, 10, 64)\n+\t\tif err == nil {\n+\t\t\treturn sec, nil\n+\t\t}\n+\t}\n+\n+\t// Fallback to git show -s --format=%ct HEAD\n+\tcmd := exec.Command(\"git\", \"show\", \"-s\", \"--format=%ct\", \"HEAD\")\n+\tif repoDir != \"\" {\n+\t\tcmd.Dir = repoDir\n+\t}\n+\tout, err := cmd.Output()\n+\tif err != nil {\n+\t\treturn 0, WrapVError(E_CONTRACT, \"git\", err)\n+\t}\n+\tsec, err := strconv.ParseInt(strings.TrimSpace(string(out)), 10, 64)\n+\tif err != nil {\n+\t\treturn 0, WrapVError(E_CONTRACT, \"git parse\", err)\n+\t}\n+\treturn sec, nil\n+}\n+\n+func getGitHeadSHA(repoDir string) (string, error) {\n+\tcmd := exec.Command(\"git\", \"rev-parse\", \"HEAD\")\n+\tif repoDir != \"\" {\n+\t\tcmd.Dir = repoDir\n+\t}\n+\tout, err := cmd.Output()\n+\tif err != nil {\n+\t\treturn \"\", WrapVError(E_CONTRACT, \"git rev-parse\", err)\n+\t}\n+\treturn strings.TrimSpace(string(out)), nil\n+}\n+\n+func collectEvidence(headSHA, repoDir string) (bool, map[string][]byte, error) {\n+\tevDir := \"docs/evidence/prverify\"\n+\tif repoDir != \"\" {","path":"cmd/reviewbundle/create.go","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"41a44446285de74eff61cdd07d2a3837665be82a","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The evidence path is hardcoded to \"docs/evidence/prverify\" which is specific to this repository's structure. This limits reusability of the tool for other projects that may organize evidence differently. Consider making this configurable or documenting this as a repository-specific assumption.\n```suggestion\n\tevDir := os.Getenv(\"PRVERIFY_EVIDENCE_DIR\")\n\tif evDir == \"\" {\n\t\tevDir = \"docs/evidence/prverify\"\n\t}\n\tif repoDir != \"\" && !filepath.IsAbs(evDir) {\n```","created_at":"2026-02-17T01:43:15Z","updated_at":"2026-02-17T01:43:18Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814607390","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814607390"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814607390"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814607390/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":258,"original_start_line":258,"start_side":"RIGHT","line":259,"original_line":259,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":259,"position":259,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814607406","pull_request_review_id":3811199286,"id":2814607406,"node_id":"PRRC_kwDOQkbgjc6nw4Au","diff_hunk":"@@ -0,0 +1,475 @@\n+package main\n+\n+import (\n+\t\"archive/tar\"\n+\t\"compress/gzip\"\n+\t\"crypto/sha256\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"path\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+type Contract struct {\n+\tContractVersion string   `json:\"contract_version\"`\n+\tMode            string   `json:\"mode\"`\n+\tRepo            string   `json:\"repo\"`\n+\tEpochSec        int64    `json:\"epoch_sec\"`\n+\tBaseRef         string   `json:\"base_ref\"`\n+\tHeadSHA         string   `json:\"head_sha\"`\n+\tWarningsCount   int      `json:\"warnings_count\"`\n+\tEvidence        Evidence `json:\"evidence\"`\n+\tTool            Tool     `json:\"tool\"`\n+}\n+\n+type Evidence struct {\n+\tRequired    bool   `json:\"required\"`\n+\tPresent     bool   `json:\"present\"`\n+\tBoundToHead bool   `json:\"bound_to_head\"`\n+\tPathPrefix  string `json:\"path_prefix\"`\n+}\n+\n+type Tool struct {\n+\tName    string `json:\"name\"`\n+\tVersion string `json:\"version\"`\n+\tBuild   string `json:\"build,omitempty\"`\n+}\n+\n+type VerifyReport struct {\n+\tContract *Contract\n+\n+\t// computed\n+\tComputedSHA256 map[string][32]byte\n+\n+\t// extracted raw files (needed for seal/checks)\n+\tSHA256SUMS     []byte\n+\tSHA256SUMSSeal []byte\n+\tWarningsTxt    []byte\n+\tEvidenceFiles  [][]byte\n+\n+\t// required layout presence\n+\tHasIndex          bool\n+\tHasContractJSON   bool\n+\tHasSHA256SUMS     bool\n+\tHasSHA256SUMSSeal bool\n+\tHasSeriesPatch    bool\n+\n+\t// evidence scan result\n+\tEvidencePresent     bool\n+\tEvidenceBoundToHead bool\n+\n+\t// captured gzip header (for post-check)\n+\tGzipModTime time.Time\n+\tGzipName    string\n+\tGzipComment string\n+\tGzipExtra   []byte\n+\tGzipOS      byte\n+}\n+\n+func VerifyBundlePath(path string) (*VerifyReport, error) {\n+\tf, err := os.Open(path)\n+\tif err != nil {\n+\t\treturn nil, WrapVError(E_PATH, path, err)\n+\t}\n+\tdefer f.Close()\n+\treturn VerifyBundle(f)\n+}\n+\n+func VerifyBundle(r io.Reader) (*VerifyReport, error) {\n+\trep, err := verifyReportFromStream(r)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif err := verifyPostConditions(rep); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn rep, nil\n+}\n+\n+func verifyReportFromStream(r io.Reader) (*VerifyReport, error) {\n+\trep := &VerifyReport{\n+\t\tComputedSHA256: make(map[string][32]byte),\n+\t}\n+\n+\tgz, err := gzip.NewReader(r)\n+\tif err != nil {\n+\t\treturn nil, WrapVError(E_GZIP, \"stream\", err)\n+\t}\n+\tdefer gz.Close()\n+\n+\t// Capture gzip header\n+\trep.GzipModTime = gz.Header.ModTime\n+\trep.GzipName = gz.Header.Name\n+\trep.GzipComment = gz.Header.Comment\n+\trep.GzipExtra = gz.Header.Extra\n+\trep.GzipOS = gz.Header.OS\n+\n+\ttr := tar.NewReader(gz)\n+\tvar prevNameCanon string\n+\tvar seenFirst bool\n+\tvar seenSec int64\n+\n+\tfor {\n+\t\thdr, err := tr.Next()\n+\t\tif err == io.EOF {\n+\t\t\tbreak\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn nil, WrapVError(E_GZIP, \"tar stream corrupted\", err)\n+\t\t}\n+\n+\t\tname := hdr.Name\n+\n+\t\tif err := validateTarOrder(name, prevNameCanon, seenFirst); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tprevNameCanon = name\n+\t\tseenFirst = true\n+\n+\t\tif err := validateTarPath(name, hdr.Typeflag); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarType(name, hdr.Typeflag); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarIdentity(name, hdr); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarTime(name, hdr, &seenSec); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif err := validateTarPAX(name, hdr); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\tupdateLayoutPresence(name, hdr, rep)\n+\n+\t\tif err := processEntryContent(tr, hdr, rep); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\treturn rep, nil\n+}\n+\n+func validateTarOrder(name, prev string, seenFirst bool) error {\n+\tif seenFirst && name < prev {\n+\t\treturn NewVError(E_ORDER, name, fmt.Sprintf(\"is not sorted (prev: %s)\", prev))\n+\t}\n+\treturn nil\n+}\n+\n+func validateTarPath(name string, typeFlag byte) error {\n+\tif strings.HasPrefix(name, \"/\") {\n+\t\treturn NewVError(E_PATH, name, \"absolute path forbidden\")\n+\t}\n+\tif strings.Contains(name, \"\\x00\") {\n+\t\treturn NewVError(E_PATH, name, \"contains NUL char\")\n+\t}\n+\tif strings.Contains(name, \"\\\\\") {\n+\t\treturn NewVError(E_PATH, name, \"contains backslash\")\n+\t}\n+\tclean := path.Clean(name)\n+\tif clean == \"..\" || strings.HasPrefix(clean, \"../\") {\n+\t\treturn NewVError(E_PATH, name, \"parent traversal prohibited\")\n+\t}\n+\n+\t// Normalize check\n+\tnormalized := clean\n+\tif typeFlag == tar.TypeDir && !strings.HasSuffix(normalized, \"/\") {\n+\t\tif name != clean && name != clean+\"/\" {\n+\t\t\treturn NewVError(E_PATH, name, \"path not normalized\")\n+\t\t}\n+\t} else {\n+\t\tif name != clean {\n+\t\t\treturn NewVError(E_PATH, name, \"path not normalized\")\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func validateTarType(name string, flag byte) error {\n+\tswitch flag {\n+\tcase tar.TypeDir, tar.TypeReg, tar.TypeSymlink:\n+\t\treturn nil\n+\tdefault:\n+\t\treturn NewVError(E_TYPE, name, fmt.Sprintf(\"forbidden type flag: %c\", flag))\n+\t}\n+}\n+\n+func validateTarIdentity(name string, hdr *tar.Header) error {\n+\tif hdr.Uid != 0 || hdr.Gid != 0 {\n+\t\treturn NewVError(E_IDENTITY, name, fmt.Sprintf(\"non-zero uid/gid: %d/%d\", hdr.Uid, hdr.Gid))\n+\t}\n+\tif hdr.Uname != \"\" || hdr.Gname != \"\" {\n+\t\treturn NewVError(E_IDENTITY, name, fmt.Sprintf(\"non-empty uname/gname: %q/%q\", hdr.Uname, hdr.Gname))\n+\t}\n+\n+\t// Phase 7.6: Mode Normalization\n+\tmode := hdr.Mode & 0777\n+\tswitch hdr.Typeflag {\n+\tcase tar.TypeDir:\n+\t\tif mode != 0755 {\n+\t\t\treturn NewVError(E_IDENTITY, name, fmt.Sprintf(\"dir mode must be 0755 (got %o)\", mode))\n+\t\t}\n+\tcase tar.TypeReg:\n+\t\t// Check for executable bit in git's bitmask sense\n+\t\t// If executable (0755) or regular (0644)\n+\t\tif mode != 0644 && mode != 0755 {\n+\t\t\treturn NewVError(E_IDENTITY, name, fmt.Sprintf(\"regular file mode must be 0644 or 0755 (got %o)\", mode))\n+\t\t}\n+\tcase tar.TypeSymlink:\n+\t\t// Symlink mode is NOT validated (Phase 7.6)\n+\t}\n+\n+\treturn nil\n+}\n+\n+func validateTarTime(name string, hdr *tar.Header, seenSec *int64) error {\n+\tts := hdr.ModTime\n+\tif ts.Nanosecond() != 0 {\n+\t\treturn NewVError(E_TIME, name, \"non-zero nanoseconds forbidden\")\n+\t}\n+\tif *seenSec == 0 {\n+\t\t*seenSec = ts.Unix()\n+\t} else {\n+\t\tif ts.Unix() != *seenSec {\n+\t\t\treturn NewVError(E_TIME, name, fmt.Sprintf(\"mtime mismatch (expected %d, got %d)\", *seenSec, ts.Unix()))\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func validateTarPAX(name string, hdr *tar.Header) error {\n+\tif len(hdr.PAXRecords) > 0 {\n+\t\tfor k := range hdr.PAXRecords {\n+\t\t\t// Phase 4.2: strict allowlist (path/linkpath only)\n+\t\t\tif k == \"path\" || k == \"linkpath\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif k == \"mtime\" || k == \"atime\" || k == \"ctime\" {\n+\t\t\t\treturn NewVError(E_PAX, name, \"forbidden PAX time key: \"+k)\n+\t\t\t}\n+\t\t\tif strings.HasPrefix(k, \"LIBARCHIVE.\") || strings.HasPrefix(k, \"SCHILY.xattr.\") {\n+\t\t\t\treturn NewVError(E_XATTR, name, \"xattr/provenance leak: \"+k)\n+\t\t\t}\n+\t\t\treturn NewVError(E_PAX, name, \"forbidden PAX key (not in allowlist): \"+k)\n+\t\t}\n+\t}\n+\tif len(hdr.Xattrs) > 0 {\n+\t\treturn NewVError(E_XATTR, name, \"xattr map present\")\n+\t}\n+\treturn nil\n+}\n+\n+func updateLayoutPresence(name string, hdr *tar.Header, rep *VerifyReport) {\n+\tswitch {\n+\tcase name == PathIndex:\n+\t\trep.HasIndex = true\n+\tcase name == PathContract:\n+\t\trep.HasContractJSON = true\n+\tcase name == PathSHA256SUMS:\n+\t\trep.HasSHA256SUMS = true\n+\tcase name == PathSHA256SUMSSeal:\n+\t\trep.HasSHA256SUMSSeal = true\n+\tcase name == PathSeriesPatch:\n+\t\trep.HasSeriesPatch = true\n+\tcase strings.HasPrefix(name, DirEvidence):\n+\t\tif hdr.Typeflag != tar.TypeDir {\n+\t\t\trep.EvidencePresent = true\n+\t\t}\n+\t}\n+}\n+\n+func processEntryContent(tr *tar.Reader, hdr *tar.Header, rep *VerifyReport) error {\n+\tif hdr.Typeflag == tar.TypeDir {\n+\t\treturn nil\n+\t}\n+\n+\tname := hdr.Name\n+\tvar hash [32]byte\n+\n+\tif hdr.Typeflag == tar.TypeSymlink {\n+\t\tif path.IsAbs(hdr.Linkname) || strings.Contains(hdr.Linkname, \"..\") {\n+\t\t\treturn NewVError(E_PATH, name, \"unsafe symlink target: \"+hdr.Linkname)\n+\t\t}\n+\t\tdata := []byte(\"symlink\\x00\" + hdr.Linkname)\n+\t\thash = sha256.Sum256(data)\n+\t} else {\n+\t\t// Regular file\n+\t\tisMeta := name == PathSHA256SUMS ||\n+\t\t\tname == PathSHA256SUMSSeal ||\n+\t\t\tname == PathContract ||\n+\t\t\tname == PathWarnings ||\n+\t\t\tstrings.HasPrefix(name, DirEvidence)\n+\n+\t\tif isMeta {\n+\t\t\t// Phase 7.5: 4MB limit for meta/evidence parsing\n+\t\t\tlr := io.LimitReader(tr, 4*1024*1024)\n+\t\t\tcontent, err := io.ReadAll(lr)\n+\t\t\tif err != nil {\n+\t\t\t\treturn WrapVError(E_GZIP, name, err)\n+\t\t\t}\n+\t\t\t// Check if we hit the limit\n+\t\t\tif int64(len(content)) == 4*1024*1024 {\n+\t\t\t\t// Peek one byte to see if there's more\n+\t\t\t\tvar b [1]byte\n+\t\t\t\tn, _ := tr.Read(b[:])\n+\t\t\t\tif n > 0 {\n+\t\t\t\t\t// We truncated. If it's evidence, we marks it as potentially incomplete/invalid for binding\n+\t\t\t\t\t// but we keep the truncated content for hash validation if it's already in SHA256SUMS.\n+\t\t\t\t\t// Actually, if it's truncated, SHA256 match will fail anyway if we hash the truncated bytes.\n+\t\t\t\t\t// The contract says: if >4MB, bound=false.\n+\t\t\t\t\tcontent = append(content, []byte(\"...[TRUNCATED]\")...)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\thash = sha256.Sum256(content)","path":"cmd/reviewbundle/verify.go","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"41a44446285de74eff61cdd07d2a3837665be82a","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"When a file exceeds the 4MB limit and is truncated, the code appends \"...[TRUNCATED]\" to the content before hashing. This will cause the hash verification to fail against SHA256SUMS. The comment at line 323 acknowledges this, but the behavior creates a confusing error message. Consider either skipping hash verification for truncated files or returning a more specific error about size limits.","created_at":"2026-02-17T01:43:15Z","updated_at":"2026-02-17T01:43:18Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814607406","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814607406"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814607406"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814607406/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":318,"original_start_line":316,"start_side":"RIGHT","line":330,"original_line":328,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":328,"position":330,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814607415","pull_request_review_id":3811199286,"id":2814607415,"node_id":"PRRC_kwDOQkbgjc6nw4A3","diff_hunk":"@@ -0,0 +1,310 @@\n+package main\n+\n+import (\n+\t\"archive/tar\"\n+\t\"compress/gzip\"\n+\t\"crypto/sha256\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+func CreateBundleUI(mode, outDir, repoDir string, stdout, stderr io.Writer) error {\n+\tepoch, err := ComputeEpochSec(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\theadSHA, err := getGitHeadSHA(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfmt.Fprintf(stdout, \"Creating bundle (mode=%s, epoch=%d, head=%s)\\n\", mode, epoch, headSHA[:12])\n+\n+\t// C4: Pre-checks\n+\tisDirty, err := isGitDirty(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif mode == ModeStrict {\n+\t\tif isDirty {\n+\t\t\treturn NewVError(E_CONTRACT, \"git\", \"repository is dirty (prohibited in strict mode)\")\n+\t\t}\n+\t\t// Evidence check will come in C5/C6\n+\t} else if mode == ModeWIP {\n+\t\tif isDirty {\n+\t\t\tfmt.Fprintln(stderr, \"WARN: repository is dirty\")\n+\t\t}\n+\t}\n+\n+\t// C4: contract.json generation\n+\tcontract := &Contract{\n+\t\tContractVersion: \"1.1\",\n+\t\tMode:            mode,\n+\t\tRepo:            \"veil-rs\", // Canonical\n+\t\tEpochSec:        epoch,\n+\t\tBaseRef:         \"main\", // Canonical entry\n+\t\tHeadSHA:         headSHA,\n+\t\tWarningsCount:   0,\n+\t\tEvidence: Evidence{\n+\t\t\tRequired:    mode == ModeStrict,\n+\t\t\tPresent:     false,\n+\t\t\tBoundToHead: false,\n+\t\t\tPathPrefix:  DirEvidence,\n+\t\t},\n+\t\tTool: Tool{\n+\t\t\tName:    \"reviewbundle\",\n+\t\t\tVersion: \"1.0.0\",\n+\t\t},\n+\t}\n+\n+\tif isDirty {\n+\t\tcontract.WarningsCount++\n+\t}\n+\n+\t// C5/C6: Actual bundle generation\n+\tpath, err := CreateBundle(contract, outDir, repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfmt.Fprintf(stdout, \"Bundle created: %s\\n\", path)\n+\treturn nil\n+}\n+\n+func CreateBundle(c *Contract, outDir, repoDir string) (string, error) {\n+\tif err := os.MkdirAll(outDir, 0755); err != nil {\n+\t\treturn \"\", WrapVError(E_PATH, outDir, err)\n+\t}\n+\n+\tts := time.Unix(c.EpochSec, 0).UTC().Format(\"20060102_150405\")\n+\tname := fmt.Sprintf(\"veil-rs_review_%s_%s_%s.tar.gz\", c.Mode, ts, c.HeadSHA[:12])\n+\toutPath := filepath.Join(outDir, name)\n+\n+\ttmpPath := outPath + \".tmp\"\n+\tf, err := os.Create(tmpPath)\n+\tif err != nil {\n+\t\treturn \"\", WrapVError(E_PATH, tmpPath, err)\n+\t}\n+\tdefer os.Remove(tmpPath)\n+\tdefer f.Close()\n+\n+\tgw := gzip.NewWriter(f)\n+\tgw.Header.ModTime = time.Unix(c.EpochSec, 0)\n+\tgw.Header.OS = 255\n+\tdefer gw.Close()\n+\n+\ttw := tar.NewWriter(gw)\n+\tdefer tw.Close()\n+\n+\t// 1. Gather files\n+\tfiles := make(map[string][]byte)\n+\n+\t// INDEX.md\n+\tfiles[PathIndex] = []byte(fmt.Sprintf(\"# Review Bundle\\n\\nMode: %s\\nEpoch: %d\\nHead: %s\\n\", c.Mode, c.EpochSec, c.HeadSHA))\n+\n+\t// patch/series.patch\n+\tpatch, err := getGitPatch(c.BaseRef, c.HeadSHA, repoDir)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tfiles[PathSeriesPatch] = patch\n+\n+\t// Evidence (Phase 7.5/8/9)\n+\tbound, evFiles, err := collectEvidence(c.HeadSHA, repoDir)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tif len(evFiles) > 0 {\n+\t\tc.Evidence.Present = true\n+\t\tc.Evidence.BoundToHead = bound\n+\t\tfor name, content := range evFiles {\n+\t\t\tfiles[name] = content\n+\t\t}\n+\t}\n+\n+\t// meta/contract.json (update with evidence findings)\n+\tcj, _ := json.MarshalIndent(c, \"\", \"  \")","path":"cmd/reviewbundle/create.go","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"41a44446285de74eff61cdd07d2a3837665be82a","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The error from json.MarshalIndent is silently ignored with `_`. While contract JSON marshaling is unlikely to fail for these simple types, ignoring the error could mask issues. Consider checking the error or at least adding a comment explaining why it's safe to ignore.\n```suggestion\n\tcj, err := json.MarshalIndent(c, \"\", \"  \")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n```","created_at":"2026-02-17T01:43:16Z","updated_at":"2026-02-17T01:43:18Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814607415","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814607415"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814607415"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814607415/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":136,"original_line":136,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":136,"position":136,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814607420","pull_request_review_id":3811199286,"id":2814607420,"node_id":"PRRC_kwDOQkbgjc6nw4A8","diff_hunk":"@@ -0,0 +1,310 @@\n+package main\n+\n+import (\n+\t\"archive/tar\"\n+\t\"compress/gzip\"\n+\t\"crypto/sha256\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+func CreateBundleUI(mode, outDir, repoDir string, stdout, stderr io.Writer) error {\n+\tepoch, err := ComputeEpochSec(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\theadSHA, err := getGitHeadSHA(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfmt.Fprintf(stdout, \"Creating bundle (mode=%s, epoch=%d, head=%s)\\n\", mode, epoch, headSHA[:12])\n+\n+\t// C4: Pre-checks\n+\tisDirty, err := isGitDirty(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif mode == ModeStrict {\n+\t\tif isDirty {\n+\t\t\treturn NewVError(E_CONTRACT, \"git\", \"repository is dirty (prohibited in strict mode)\")\n+\t\t}\n+\t\t// Evidence check will come in C5/C6\n+\t} else if mode == ModeWIP {\n+\t\tif isDirty {\n+\t\t\tfmt.Fprintln(stderr, \"WARN: repository is dirty\")\n+\t\t}\n+\t}\n+\n+\t// C4: contract.json generation\n+\tcontract := &Contract{\n+\t\tContractVersion: \"1.1\",\n+\t\tMode:            mode,\n+\t\tRepo:            \"veil-rs\", // Canonical","path":"cmd/reviewbundle/create.go","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"41a44446285de74eff61cdd07d2a3837665be82a","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The Repo field is hardcoded to \"veil-rs\" which is specific to this repository. This makes the tool less reusable for other projects. Consider deriving the repo name from the git remote URL or allowing it to be configured.","created_at":"2026-02-17T01:43:16Z","updated_at":"2026-02-17T01:43:18Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814607420","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814607420"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814607420"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814607420/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":53,"original_line":53,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":53,"position":53,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814607424","pull_request_review_id":3811199286,"id":2814607424,"node_id":"PRRC_kwDOQkbgjc6nw4BA","diff_hunk":"@@ -0,0 +1,310 @@\n+package main\n+\n+import (\n+\t\"archive/tar\"\n+\t\"compress/gzip\"\n+\t\"crypto/sha256\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+func CreateBundleUI(mode, outDir, repoDir string, stdout, stderr io.Writer) error {\n+\tepoch, err := ComputeEpochSec(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\theadSHA, err := getGitHeadSHA(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfmt.Fprintf(stdout, \"Creating bundle (mode=%s, epoch=%d, head=%s)\\n\", mode, epoch, headSHA[:12])\n+\n+\t// C4: Pre-checks\n+\tisDirty, err := isGitDirty(repoDir)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif mode == ModeStrict {\n+\t\tif isDirty {\n+\t\t\treturn NewVError(E_CONTRACT, \"git\", \"repository is dirty (prohibited in strict mode)\")\n+\t\t}\n+\t\t// Evidence check will come in C5/C6\n+\t} else if mode == ModeWIP {\n+\t\tif isDirty {\n+\t\t\tfmt.Fprintln(stderr, \"WARN: repository is dirty\")\n+\t\t}\n+\t}\n+\n+\t// C4: contract.json generation\n+\tcontract := &Contract{\n+\t\tContractVersion: \"1.1\",\n+\t\tMode:            mode,\n+\t\tRepo:            \"veil-rs\", // Canonical\n+\t\tEpochSec:        epoch,\n+\t\tBaseRef:         \"main\", // Canonical entry","path":"cmd/reviewbundle/create.go","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"41a44446285de74eff61cdd07d2a3837665be82a","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The BaseRef is hardcoded to \"main\" which assumes all repositories use \"main\" as their default branch. Some repositories might use \"master\" or other branch names. The legacy bash script had sophisticated fallback logic (BASE_REF with fallbacks to main/master). This should either be configurable or preserve the fallback logic.","created_at":"2026-02-17T01:43:16Z","updated_at":"2026-02-17T01:43:18Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814607424","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814607424"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814607424"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814607424/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":55,"original_line":55,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":55,"position":55,"subject_type":"line"},{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814607436","pull_request_review_id":3811199286,"id":2814607436,"node_id":"PRRC_kwDOQkbgjc6nw4BM","diff_hunk":"@@ -0,0 +1,101 @@\n+# REVIEW BUNDLE CONTRACT v1.1\n+\n+## 1. Mission & Philosophy\n+Review Bundle は「監査に耐える契約成果物 (contract artifact)」である。\n+作成ツール (go / bash) によらず、同一入力からは常に同一の bundle (byte-identical) が生成されなければならない。\n+また、verify コマンドは bundle の内容のみから正当性を証明できなければならない。\n+\n+## 2. Canonical Structure (Layout)\n+Bundle MUST be a `.tar.gz` file containing the following structure:\n+\n+- `review/INDEX.md` : Human-readable summary\n+- `review/meta/contract.json` : Machine-readable metadata (version, mode, base/head, epoch, counts)\n+- `review/meta/SHA256SUMS` : Checksums of all files (excluding itself)\n+- `review/meta/SHA256SUMS.sha256` : Checksum of SHA256SUMS\n+- `review/patch/series.patch` : Full patch from base to head\n+- `review/evidence/**` : Proof of verification (strict mode: required)\n+- `review/files/**` : Source file snapshots","path":"docs/ops/REVIEW_BUNDLE.md","commit_id":"0fc4566ac33b95a96cf341eb2d9835f9e2fdc236","original_commit_id":"41a44446285de74eff61cdd07d2a3837665be82a","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The contract documentation mentions \"review/files/**\" as part of the canonical structure (line 17), but the Go implementation in create.go doesn't appear to generate this directory. The legacy bash script had logic to copy changed files to the files/ directory, but this functionality seems to be missing from the Go implementation.","created_at":"2026-02-17T01:43:16Z","updated_at":"2026-02-17T01:43:16Z","html_url":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814607436","pull_request_url":"https://api.github.com/repos/mt4110/veil-rs/pulls/78","_links":{"self":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814607436"},"html":{"href":"https://github.com/mt4110/veil-rs/pull/78#discussion_r2814607436"},"pull_request":{"href":"https://api.github.com/repos/mt4110/veil-rs/pulls/78"}},"reactions":{"url":"https://api.github.com/repos/mt4110/veil-rs/pulls/comments/2814607436/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":17,"original_line":17,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":17,"position":17,"subject_type":"line"}]