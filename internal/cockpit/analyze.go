package cockpit

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

// Signal Spec v1
type SignalV1 struct {
	Id                string                 `json:"id"`
	Severity          string                 `json:"severity"` // info, warn, high, critical
	Confidence        string                 `json:"confidence"` // low, med, high
	Evidence          []SignalEvidence       `json:"evidence"`
	Summary           string                 `json:"summary"`
	RecommendedAction string                 `json:"recommended_action"`
	EstimatedEffort   string                 `json:"estimated_effort"` // xs, s, m
	FixTarget         string                 `json:"fix_target"`
}

type SignalEvidence struct {
	Path    string `json:"path"`
	Pointer string `json:"pointer"`
	Value   string `json:"value"`
}

// Analyze performs Phase 14 analysis on the dogfood directory
func Analyze(overrideWeekID string) error {
	weekID := overrideWeekID
	if weekID == "" {
		weekID = GetWeekID()
	}
	dirName := weekID + "-Tokyo"
	docsDir := filepath.Join("docs", "dogfood", dirName)

	if _, err := os.Stat(docsDir); os.IsNotExist(err) {
		return fmt.Errorf("evidence directory not found: %s", docsDir)
	}

	signals := []SignalV1{}

	// 1. Check Scorecard
	if s := checkScorecard(docsDir); s != nil {
		signals = append(signals, *s)
	}

	// 2. Check Contract
	if s := checkContract(docsDir); s != nil {
		signals = append(signals, *s)
	}

	// 3. Check Log
	if s := checkLog(docsDir); s != nil {
		signals = append(signals, *s)
	}

	// 4. Check Metrics
	if s := checkMetrics(docsDir); s != nil {
		signals = append(signals, *s)
	}

	// Artifact Generation
	if err := writeSignals(docsDir, signals); err != nil {
		return err
	}
	if err := writeInsights(docsDir, weekID, signals); err != nil {
		return err
	}
	if err := writeActions(docsDir, signals); err != nil {
		return err
	}
	if err := writeSummary(docsDir, weekID, signals); err != nil {
		return err
	}

	return nil
}

func checkScorecard(docsDir string) *SignalV1 {
	scPath := filepath.Join(docsDir, "scorecard.txt")
	scContent, scErr := os.ReadFile(scPath)
	if os.IsNotExist(scErr) {
		return &SignalV1{
			Id:                "SCORECARD_FILE_MISSING",
			Severity:          "high",
			Confidence:        "high",
			Evidence:          []SignalEvidence{{Path: scPath, Pointer: "file", Value: "missing"}},
			Summary:           "Scorecard artifact is missing.",
			RecommendedAction: "Ensure workflow always generates scorecard.txt (even placeholder).",
			EstimatedEffort:   "s",
			FixTarget:         "workflow",
		}
	}

	content := string(scContent)
	if strings.Contains(content, "executable file not found") || strings.Contains(content, "scorecard unavailable") {
		return &SignalV1{
			Id:                "SCORECARD_MISSING",
			Severity:          "high",
			Confidence:        "high",
			Evidence:          []SignalEvidence{{Path: scPath, Pointer: "content", Value: "executable file not found"}},
			Summary:           "Scorecard CLI is missing from the execution environment.",
			RecommendedAction: "Add `scorecard` to `flake.nix` runtimeInputs or workflow.",
			EstimatedEffort:   "xs",
			FixTarget:         "nix",
		}
	}
	return nil
}

func checkContract(docsDir string) *SignalV1 {
	// Phase 14 Contract:
	// - Phase 13 inputs (metrics, scorecard, worklist/report) are valid.
	// - Phase 14 outputs (signals, INSIGHTS, ACTIONS, SUMMARY) are generated by us.
	// We do NOT check for Phase 14 outputs here (that would be self-contradiction).
	// We only check for critical Phase 13 inputs if their absence is fatal.
	// Log and Scorecard are checked separately.
	// Currently nothing else "must" be checked here that isn't already covered.

	// If we wanted to check for old artifacts, we could.
	// For now, report.md is acceptable for Phase 13 as per "Tiny Fix 2".
	return nil
}

func checkLog(docsDir string) *SignalV1 {
	logPath := filepath.Join(docsDir, "run.log")
	if _, err := os.Stat(logPath); os.IsNotExist(err) {
		return &SignalV1{
			Id:                "MISSING_ARTIFACT_LOG",
			Severity:          "info",
			Confidence:        "high",
			Evidence:          []SignalEvidence{{Path: docsDir, Pointer: "file_list", Value: "run.log missing"}},
			Summary:           "Execution log `run.log` is missing.",
			RecommendedAction: "Verify CI capture configuration in `dogfood_weekly.yml`.",
			EstimatedEffort:   "s",
			FixTarget:         "workflow",
		}
	}
	return nil
}

func checkMetrics(docsDir string) *SignalV1 {
	metricsPath := filepath.Join(docsDir, "metrics_v1.json")
	mContent, mErr := os.ReadFile(metricsPath)
	if mErr == nil {
		var m MetricsV1
		if err := json.Unmarshal(mContent, &m); err == nil {
			if count, ok := m.Metrics.CountsByReason["unexpected"]; ok && count > 0 {
				return &SignalV1{
					Id:                "UNEXPECTED_FAILURE_COUNT",
					Severity:          "warn",
					Confidence:        "med",
					Evidence:          []SignalEvidence{{Path: metricsPath, Pointer: "$.metrics.counts_by_reason.unexpected", Value: fmt.Sprintf("%d", count)}},
					Summary:           fmt.Sprintf("%d unexpected failure events recorded.", count),
					RecommendedAction: "Investigate root cause in logs.",
					EstimatedEffort:   "m",
					FixTarget:         "code:unknown",
				}
			}
		}
	}
	return nil
}

func writeSignals(dir string, signals []SignalV1) error {
	data, _ := json.MarshalIndent(signals, "", "  ")
	return os.WriteFile(filepath.Join(dir, "signals_v1.json"), append(data, '\n'), 0644)
}

func writeInsights(dir, weekID string, signals []SignalV1) error {
	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("# System Insights (%s)\n\n", weekID))

	if len(signals) == 0 {
		sb.WriteString("No significant signals detected. System appears stable.\n")
	} else {
		for i, s := range signals {
			sb.WriteString(fmt.Sprintf("## %d. %s (%s)\n", i+1, s.Id, strings.Title(s.Severity)))
			sb.WriteString(s.Summary + "\n")
			sb.WriteString("Conclusion: " + s.RecommendedAction + "\n\n")
		}
	}
	return os.WriteFile(filepath.Join(dir, "INSIGHTS.md"), []byte(sb.String()), 0644)
}

func writeActions(dir string, signals []SignalV1) error {
	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("# Recommended Actions (Top %d)\n\n", min(5, len(signals))))

	if len(signals) == 0 {
		sb.WriteString("No immediate actions required.\n")
	} else {
		// Ranking logic: Critical > High > Warn > Info
		sort.SliceStable(signals, func(i, j int) bool {
			return getSeverityWeight(signals[i].Severity) > getSeverityWeight(signals[j].Severity)
		})

		for i, s := range signals {
			if i >= 5 { break }
			ev := ""
			if len(s.Evidence) > 0 {
				ev = fmt.Sprintf("Evidence: %s", s.Evidence[0].Path)
			}
			sb.WriteString(fmt.Sprintf("%d. [%s][%s][%s] %s (%s)\n",
				i+1, s.Severity, s.EstimatedEffort, s.FixTarget, s.RecommendedAction, ev))
		}
	}
	return os.WriteFile(filepath.Join(dir, "ACTIONS.md"), []byte(sb.String()), 0644)
}

func writeSummary(dir, weekID string, signals []SignalV1) error {
	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("# Weekly Dogfood Summary (%s)\n\n", weekID))
	
	status := "Healthy"
	highestSev := "Info"
	for _, s := range signals {
		if getSeverityWeight(s.Severity) > getSeverityWeight(highestSev) {
			highestSev = strings.Title(s.Severity)
			status = "Warning"
			if s.Severity == "critical" {
				status = "Critical"
			}
		}
	}
	
	sb.WriteString(fmt.Sprintf("**Status**: %s\n", status))
	sb.WriteString(fmt.Sprintf("**Severity**: %s\n\n", highestSev))
	
	sb.WriteString("## Key Signals\n")
	for _, s := range signals {
		if getSeverityWeight(s.Severity) >= 10 { // Warn or higher
			sb.WriteString(fmt.Sprintf("- **%s**: %s (%s)\n", s.Id, s.Summary, strings.Title(s.Severity)))
		}
	}

	return os.WriteFile(filepath.Join(dir, "SUMMARY.md"), []byte(sb.String()), 0644)
}

func getSeverityWeight(sev string) int {
	switch strings.ToLower(sev) {
	case "critical": return 100
	case "high": return 30
	case "warn": return 10
	case "info": return 1
	default: return 0
	}
}

func min(a, b int) int {
	if a < b { return a }
	return b
}
